!function(e){var t={};function i(n){if(t[n])return t[n].exports;var s=t[n]={i:n,l:!1,exports:{}};return e[n].call(s.exports,s,s.exports,i),s.l=!0,s.exports}i.m=e,i.c=t,i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)i.d(n,s,function(t){return e[t]}.bind(null,s));return n},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=1)}([function(e,t,i){"use strict";let n;function s(e){if(null===e||"object"!=typeof e)throw new Error("Invalid arguments. Must pass an identity object");const t="string"==typeof e.uuid,i=!e.name||"string"==typeof e.name;if(!t&&!i)throw new Error("Invalid Identity provided: uuid and name must be strings");if(!t)throw new Error("Invalid Identity provided: uuid must be a string");if(!i)throw new Error("Invalid Identity provided: name must be a string or undefined");return{uuid:e.uuid,name:e.name||e.uuid}}function o(e){return!(!e.expression||"string"!=typeof e.expression||void 0!==e.flags&&"string"!=typeof e.flags||void 0!==e.invert&&"boolean"!=typeof e.invert)}Object.defineProperty(t,"__esModule",{value:!0}),t.SERVICE_IDENTITY={uuid:"layouts-service",name:"layouts-service"},t.SERVICE_CHANNEL="of-layouts-service-v1",t.getId=function(){return n||(n=s(fin.Window.me)),n},t.parseIdentity=s,t.parseIdentityRule=function(e){if(null===e||"object"!=typeof e)throw new Error("Invalid arguments. Must pass an identity object");const t="string"==typeof e.uuid||o(e.uuid),i=!e.name||"string"==typeof e.name||o(e.name);if(!t&&!i)throw new Error("Invalid Identity provided: uuid and name must be strings or RegEx objects");if(!t)throw new Error("Invalid Identity provided: uuid must be a string or RegEx object");if(!i)throw new Error("Invalid Identity provided: name must be a string, RegEx object, or undefined");return{uuid:e.uuid,name:e.name||e.uuid}},function(e){e.CREATETABGROUP="CREATETABGROUP",e.SETTABSTRIP="SETTABSTRIP",e.GETTABS="GETTABS",e.TAB_WINDOW_TO_WINDOW="TAB_WINDOW_TO_WINDOW",e.REMOVETAB="REMOVETAB",e.SETACTIVETAB="SETACTIVETAB",e.MINIMIZETABGROUP="MINIMIZETABGROUP",e.MAXIMIZETABGROUP="MAXIMIZETABGROUP",e.CLOSETABGROUP="CLOSETABGROUP",e.RESTORETABGROUP="RESTORETABGROUP",e.REORDERTABS="REORDERTABS",e.STARTDRAG="STARTDRAG",e.ENDDRAG="ENDDRAG",e.UPDATETABPROPERTIES="UPDATETABPROPERTIES",e.CLOSETAB="CLOSETAB"}(t.TabAPI||(t.TabAPI={})),function(e){e.RESTORE_HANDLER="SET-RESTORE-HANDLER",e.GENERATE_HANDLER="SET-GENERATE-HANDLER",e.GENERATE_LAYOUT="GENERATE-WORKSPACE",e.RESTORE_LAYOUT="RESTORE-WORKSPACE",e.APPLICATION_READY="WORKSPACE-APP-READY"}(t.WorkspaceAPI||(t.WorkspaceAPI={})),function(e){e.UNDOCK_WINDOW="UNDOCK-WINDOW",e.UNDOCK_GROUP="UNDOCK-GROUP",e.GET_DOCKED_WINDOWS="GET-DOCKED-WINDOWS"}(t.SnapAndDockAPI||(t.SnapAndDockAPI={})),function(e){e.REGISTER="REGISTER",e.DEREGISTER="DEREGISTER"}(t.RegisterAPI||(t.RegisterAPI={}))},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(27),s=i(28),o=i(0),r=i(30),a=i(33),d=i(10),c=i(36),l=i(17),h=i(43),u=i(6);fin.desktop.main(w);const p=[1,1.5,2];async function w(){const e=await fin.System.getMonitorInfo();if(!p.some(t=>t===e.deviceScaleFactor)){console.error("Desktop has non-standard display scaling. Notifying user and disabling all layouts functionality.");const e="OpenFin Layouts will only work with monitors that are set to a scaling ratio of 100%, 150% or 200%. This can be changed in monitor or display settings.\n\n\nPlease contact support@openfin.co with any further questions.",t=await fin.InterApplicationBus.Channel.create(o.SERVICE_CHANNEL);return t.onConnection(i=>{t.dispatch(i,"WARN",e)}),void t.setDefaultAction(()=>{throw Error(e)})}t.config=window.config=new n.Store(i(44)),t.loader=window.loader=new s.Loader(t.config,"layouts",{enabled:!1}),t.model=window.model=new a.DesktopModel(t.config),t.windowHandler=new u.WindowHandler(t.config),t.snapService=window.snapService=new c.SnapService(t.model,t.config),t.tabService=window.tabService=new h.TabService(t.model,t.config),t.apiHandler=window.apiHandler=new r.APIHandler(t.model,t.config,t.snapService,t.tabService),d.DesktopTabGroup.windowPool,await l.win10Check,await t.apiHandler.registerListeners()}t.main=w,navigator.serviceWorker.register("./sw.js",{scope:"./"})},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(11),s=i(12),o=i(31),r=i(15),a=i(4),d=i(3),c=i(5);class l{constructor(){this.onModified=new n.Signal2,this.onTransform=new n.Signal2,this.onCommit=new n.Signal2,this.onWindowAdded=new n.Signal2,this.onWindowRemoved=new n.Signal2,this._id=l._nextId++,this._entities=[],this._windows=[],this.rootWindow=null,this._resizeConstraintsSuspended=!1;const e=this.calculateProperties.bind(this);this._localBounds=new o.CalculatedProperty(e),this._validateGroup=new r.Debounced(this.validateGroupInternal,this),this.onModified.add(this.onGroupModified.bind(this)),l.onCreated.emit(this)}get id(){return this._id}get origin(){return this._localBounds.value.center}get halfSize(){return this._localBounds.value.halfSize}get center(){if(this.rootWindow){const e=this._localBounds.value.center,t=this.rootWindow.currentState.center;return{x:t.x+e.x,y:t.y+e.y}}return{x:0,y:0}}get length(){return this._windows.length}get entities(){return this._entities.slice()}get windows(){return this._windows.slice()}addWindow(e){if(!this._windows.includes(e)){const t=this.isNonTrivial(),i=e.snapGroup===this?e.prevGroup:e.snapGroup;i&&i.removeWindow(e),e.onModified.add(this.onWindowModified,this),e.onTransform.add(this.onWindowTransform,this),e.onCommit.add(this.onWindowCommit,this),e.onTabGroupChanged.add(this.onWindowTabGroupChanged,this),e.onTeardown.add(this.onWindowTeardown,this),this._windows.push(e),this.buildEntities(),this.checkRoot(),e.snapGroup!==this&&e.setSnapGroup(this),this._localBounds.markStale();const n=this.isNonTrivial();t&&n?e.sendEvent({type:"window-docked"}):!t&&n?this._windows.forEach(e=>e.sendEvent({type:"window-docked"})):t&&!n&&this._windows.forEach(e=>e.sendEvent({type:"window-undocked"})),this.onWindowAdded.emit(this,e)}}validate(){this._validateGroup.call()}isNonTrivial(){return this._entities.length>=2}suspendResizeConstraints(){if(this._windows.length>1&&!this._resizeConstraintsSuspended){const e={resizableMin:!0,resizableMax:!0,minSize:0,maxSize:Number.MAX_SAFE_INTEGER},t={x:e,y:e};this._resizeConstraintsSuspended=!0;for(const e of this._windows)e.refresh().then(()=>{this._resizeConstraintsSuspended&&e.applyOverride("resizeConstraints",t)})}}restoreResizeConstraints(){if(this._resizeConstraintsSuspended){for(const e of this._windows)e.resetOverride("resizeConstraints");this._resizeConstraintsSuspended=!1}}validateGroupInternal(){const e=this.getContiguousEntities(this.entities);if(e.length>1)for(const t of e.slice(1)){const e=new l;for(const i of t)i.setSnapGroup(e)}}getContiguousEntities(e){const t=new Array(e.length);for(let i=0;i<e.length;i++){t[i]=[];for(let n=0;n<e.length;n++)i!==n&&r(e[i],e[n])&&t[i].push(e[n])}const i=[],n=e.slice();for(;n.length>0;){const e=[];o(n[0],e),i.push(e)}return i;function o(i,s){const r=e.indexOf(i);if(!s.includes(i)){s.push(i),n.splice(n.indexOf(i),1);for(let e=0;e<t[r].length;e++)o(t[r][e],s)}}function r(e,t){const i=d.RectUtils.distance(e.currentState,t.currentState);return!(!e.tabGroup||e.tabGroup!==t.tabGroup)||!e.currentState.hidden&&!t.currentState.hidden&&!!(i.border(s.ADJACENCY_FUZZ_DISTANCE)&&Math.abs(i.maxAbs)>s.MIN_OVERLAP)}}removeWindow(e){const t=this._windows.indexOf(e);if(t>=0){const i=this.isNonTrivial();this._windows.splice(t,1),this.buildEntities(),e.onModified.remove(this.onWindowModified,this),e.onTransform.remove(this.onWindowTransform,this),e.onCommit.remove(this.onWindowCommit,this),e.onTabGroupChanged.remove(this.onWindowTabGroupChanged,this),e.onTeardown.remove(this.onWindowTeardown,this),this.checkRoot(),this._localBounds.markStale();const n=this.isNonTrivial();i&&n?e.isReady&&e.sendEvent({type:"window-undocked"}):i&&!n?(e.isReady&&e.sendEvent({type:"window-undocked"}),this._windows.forEach(e=>{e.isReady&&e.sendEvent({type:"window-undocked"})})):!i&&n&&this._windows.forEach(e=>{e.isReady&&e.sendEvent({type:"window-docked"})}),this.onModified.emit(this,e),this.onWindowRemoved.emit(this,e),0===this._windows.length&&l.onDestroyed.emit(this)}}buildEntities(){const e=this._entities;e.length=0,this._windows.forEach(t=>{const i=t.tabGroup,n=i||t;e.includes(n)||e.push(n)})}checkRoot(){let e=this._windows[0]||null;const t=e&&e.tabGroup;t&&t.tabs.length>=2&&(e=t.window),this.rootWindow!==e&&(this.rootWindow=e,this._localBounds.markStale())}onGroupModified(e,t){this.windows.includes(t)?this._validateGroup.postpone():this._validateGroup.call()}onWindowModified(e){this._localBounds.markStale(),this.onModified.emit(this,e)}onWindowTransform(e,t){this._validateGroup.postpone(),c.eTransformType.MOVE,this.onTransform.emit(this,t),0!=(t&c.eTransformType.RESIZE)&&this._localBounds.markStale()}onWindowCommit(e,t){this.onCommit.emit(this,t)}onWindowTabGroupChanged(e){const t=this.isNonTrivial();this.buildEntities(),this.checkRoot();const i=this.isNonTrivial();!t&&i?this._windows.forEach(e=>e.sendEvent({type:"window-docked"})):t&&!i&&this._windows.forEach(e=>e.sendEvent({type:"window-undocked"}))}async onWindowTeardown(e){e.snapGroup.removeWindow(e)}calculateProperties(){let e=this._windows,t=e.length;if(e.length>1&&(t=(e=e.filter(e=>{const t=e.currentState;return!t.hidden&&"normal"===t.state})).length),0===t)return{center:{x:0,y:0},halfSize:{x:0,y:0}};if(1===t)return{center:{x:0,y:0},halfSize:a.PointUtils.clone(this.rootWindow.currentState.halfSize)};{let i=e[0].currentState;const n={x:i.center.x-i.halfSize.x,y:i.center.y-i.halfSize.y},s={x:i.center.x+i.halfSize.x,y:i.center.y+i.halfSize.y};for(let o=1;o<t;o++)i=e[o].currentState,n.x=Math.min(n.x,i.center.x-i.halfSize.x),n.y=Math.min(n.y,i.center.y-i.halfSize.y),s.x=Math.max(s.x,i.center.x+i.halfSize.x),s.y=Math.max(s.y,i.center.y+i.halfSize.y);const o=this.rootWindow.currentState.center;return{center:{x:(n.x+s.x)/2-o.x,y:(n.y+s.y)/2-o.y},halfSize:{x:(s.x-n.x)/2,y:(s.y-n.y)/2}}}}}l._nextId=1,l.onCreated=new n.Signal1,l.onDestroyed=new n.Signal1,t.DesktopSnapGroup=l},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(4);class s{constructor(e,t){this.x=e,this.y=t}get length(){return Math.sqrt(this.x*this.x+this.y*this.y)}get lengthSquared(){return this.x*this.x+this.y*this.y}get min(){return Math.min(this.x,this.y)}get max(){return Math.max(this.x,this.y)}get minAbs(){return Math.abs(this.x)<=Math.abs(this.y)?this.x:this.y}get maxAbs(){return Math.abs(this.x)>=Math.abs(this.y)?this.x:this.y}within(e){return this.x<e&&this.y<e}border(e){return Math.abs(this.x)<=e&&this.y<=e||Math.abs(this.y)<=e&&this.x<=e}}t.MeasureResult=s;t.RectUtils=class{static distance(e,t){const i=e.center,n=e.halfSize,o=t.center,r=t.halfSize,a=Math.abs(o.x-i.x)-(n.x+r.x),d=Math.abs(o.y-i.y)-(n.y+r.y);return new s(a,d)}static distanceFromParts(e,t,i,n){const o=Math.abs(i.x-e.x)-(t.x+n.x),r=Math.abs(i.y-e.y)-(t.y+n.y);return new s(o,r)}static isPointInRect(e,t,i){return Math.abs(e.x-i.x)<=t.x&&Math.abs(e.y-i.y)<t.y}static isEqual(e,t){return n.PointUtils.isEqual(e.center,t.center)&&n.PointUtils.isEqual(e.halfSize,t.halfSize)}static convertToCenterHalfSize(e){return{center:{x:(e.right+e.left)/2,y:(e.bottom+e.top)/2},halfSize:{x:(e.right-e.left)/2,y:(e.bottom-e.top)/2}}}static overlappingArea(e,t){const i=n.PointUtils.scale(this.distanceFromParts(e.center,e.halfSize,t.center,t.halfSize),-1);return Math.max(0,i.x)*Math.max(0,i.y)}static clone(e){return{center:n.PointUtils.clone(e.center),halfSize:n.PointUtils.clone(e.halfSize)}}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.PointUtils=class{static isEqual(e,t){return e.x===t.x&&e.y===t.y}static assign(e,t){return e.x=t.x,e.y=t.y,e}static clone(e){return{x:e.x,y:e.y}}static isPoint(e){return void 0!==e.x&&void 0!==e.y}static lengthSquared(e){return Math.sqrt(e.x*e.x+e.y*e.y)}static difference(e,t){return{x:t.x-e.x,y:t.y-e.y}}static scale(e,t){return{x:e.x*t,y:e.y*t}}}},function(e,t,i){"use strict";var n=this&&this.__rest||function(e,t){var i={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(i[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(n=Object.getOwnPropertySymbols(e);s<n.length;s++)t.indexOf(n[s])<0&&(i[n[s]]=e[n[s]])}return i},s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const o=s(i(16)),r=i(0),a=i(9),d=i(1),c=i(11),l=i(15),h=i(17),u=i(32),p=i(2);var w,f,g;!function(e){e[e.MOVE=1]="MOVE",e[e.RESIZE=2]="RESIZE"}(w=t.eTransformType||(t.eTransformType={})),function(e){e[e.APPLICATION=0]="APPLICATION",e[e.SERVICE=1]="SERVICE",e[e.SERVICE_TEMPORARY=2]="SERVICE_TEMPORARY"}(f||(f={})),function(e){e[e.STARTING=0]="STARTING",e[e.READY=1]="READY",e[e.ENDING=2]="ENDING"}(g||(g={}));const m=2,y=2;class b{constructor(e,t,i){this.onModified=new c.Signal1,this.onTransform=new c.Signal2,this.onCommit=new c.Signal2,this.onTabGroupChanged=new c.Signal1,this.onTeardown=new c.Signal1(c.Aggregators.AWAIT_VOID),this._registeredListeners=new Map,this._moveInProgress=!1;const n=b.getIdentity(t);this._model=e,this._identity=n,this._scope=Object.assign({level:"window"},n),this._id=`${n.uuid}/${n.name}`,this._pendingActions=[],this._actionTags=new WeakMap,this._lifecycleStage=g.STARTING,b.isWindow(t)?i?(this._window=t,this._lifecycleStage=g.READY):(this._window=t,this.addPendingActions("Fetch initial window state "+this._id,b.getWindowState(this._window).then(e=>{this._currentState=e,this._applicationState=Object.assign({},this._currentState),this._lifecycleStage=g.READY,this.addListeners()}))):(this._window=fin.Window.wrapSync({uuid:fin.Application.me.uuid,name:t.name}),this.addPendingActions("Add window "+this._id,fin.Window.create(t).then(async e=>{this._window=e,this._currentState=await b.getWindowState(e),this._applicationState=Object.assign({},this._currentState),this._lifecycleStage=g.READY,this.addListeners()}))),i||(i=this.createTemporaryState()),this._currentState=this.cloneState(i),this._applicationState=this.cloneState(i),this._modifiedState={},this._temporaryState={},this._snapGroup=new p.DesktopSnapGroup,this._tabGroup=null,this._prevGroup=null,this._snapGroup.addWindow(this),this._userInitiatedBoundsChange=null,this.isReady&&this.addListeners(),b.onCreated.emit(this)}static async getWindowState(e){return Promise.all([e.getOptions(),e.getState(),e.getInfo(),e.isShowing(),e.getBounds()]).then(t=>{const i=t[0],n=t[1],s=t[2],o=t[3],a=t[4],d={x:a.width/2,y:a.height/2},c={x:a.left+d.x,y:a.top+d.y};h.isWin10()&&i.frame&&(d.x-=7,d.y-=3.5,c.y-=3.5),i.resizeRegion=i.resizeRegion||{sides:{}};const l={x:{resizableMin:!!i.resizable&&!1!==i.resizeRegion.sides.left,resizableMax:!!i.resizable&&!1!==i.resizeRegion.sides.right,minSize:i.minWidth||0,maxSize:i.maxWidth&&i.maxWidth>0?i.maxWidth:Number.MAX_SAFE_INTEGER},y:{resizableMin:!!i.resizable&&!1!==i.resizeRegion.sides.top,resizableMax:!!i.resizable&&!1!==i.resizeRegion.sides.bottom,minSize:i.minHeight||0,maxSize:i.maxHeight&&i.maxHeight>0?i.maxHeight:Number.MAX_SAFE_INTEGER}},{title:u,url:p}=s;let w=u;if(u&&p&&p.indexOf(u)>=0){const t=new URL(p);[[t.host,t.pathname,t.search,t.hash].join(""),[t.host,t.pathname].join("")].indexOf(u)>=0&&(w=e.identity.name||"")}return e.identity.uuid===r.SERVICE_IDENTITY.uuid&&e.identity.name&&e.identity.name.startsWith("Placeholder-")&&(w="Loading..."),{center:c,halfSize:d,resizeConstraints:l,frame:i.frame,hidden:!o,state:n,icon:i.icon||`https://www.google.com/s2/favicons?domain=${i.url}`,title:w,showTaskbarIcon:i.showTaskbarIcon,opacity:i.opacity,alwaysOnTop:i.alwaysOnTop,maximizable:i.maximizable}})}static async transaction(e,t){const i={windows:e,remove:new l.Debounced(()=>{const e=this.activeTransactions.indexOf(i);e>=0&&this.activeTransactions.splice(e,1)},this)};this.activeTransactions.push(i);try{await Promise.all(e.map(e=>e.sync())),await Promise.all(e.map(e=>e.unsnap())),await t(e),await Promise.all(e.map(e=>e.snap()))}finally{i.remove.call()}}static isWindow(e){return e.hasOwnProperty("identity")}static getIdentity(e){return this.isWindow(e)?e.identity:{uuid:r.SERVICE_IDENTITY.uuid,name:e.name}}async teardown(){if(this.cleanupListeners(),this._tabGroup&&await this._tabGroup.removeTab(this),this.isReady){const e=Object.keys(this._temporaryState);await Promise.all(e.map(e=>this.resetOverride(e))),this._window.leaveGroup()}await this.onTeardown.emit(this),b.onDestroyed.emit(this),this._lifecycleStage=g.ENDING}createTemporaryState(){return{center:{x:500,y:300},halfSize:{x:200,y:100},frame:!1,hidden:!1,state:"normal",icon:"",title:"",showTaskbarIcon:!0,resizeConstraints:{x:{minSize:0,maxSize:Number.MAX_SAFE_INTEGER,resizableMin:!0,resizableMax:!0},y:{minSize:0,maxSize:Number.MAX_SAFE_INTEGER,resizableMin:!0,resizableMax:!0}},opacity:1,alwaysOnTop:!1,maximizable:!0}}get[Symbol.toStringTag](){return this._id}get id(){return this._id}get identity(){return this._identity}get scope(){return this._scope}get isReady(){return this._lifecycleStage===g.READY}get isActive(){const e=this._currentState;return!e.hidden&&(e.opacity>0||this.applicationState.opacity>0)&&"minimized"!==e.state}get snapGroup(){return this._snapGroup}get tabGroup(){return this._tabGroup}get prevGroup(){return this._prevGroup}get currentState(){if("maximized"===this._currentState.state){const e=this._model.getMonitorByRect(this._currentState);return Object.assign({},this._currentState,e)}return this._currentState}get beforeMaximizeBounds(){return{center:this._currentState.center,halfSize:this._currentState.halfSize}}get applicationState(){return this._applicationState}get moveInProgress(){return this._moveInProgress}async setSnapGroup(e){if(e!==this._snapGroup){const t=this._snapGroup.windows.length>1;this.addToSnapGroup(e),t&&await this.unsnap(),this._snapGroup.windows.length>1&&await this.snap()}return Promise.resolve()}applyOffset(e,t){const i={};return e&&(i.center={x:this._currentState.center.x+e.x,y:this._currentState.center.y+e.y}),t&&(i.center=i.center||Object.assign({},this._currentState.center),i.halfSize=t,i.center.x+=t.x-this._currentState.halfSize.x,i.center.y+=t.y-this._currentState.halfSize.y),this.updateState(i,f.SERVICE)}setTabGroup(e){if(e?console.log("Added "+this._id+" to "+e.id):this._tabGroup&&console.log("Removed "+this._id+" from "+this._tabGroup.id),this._tabGroup=e,this.onTabGroupChanged.emit(this),this._identity.uuid!==r.SERVICE_IDENTITY.uuid&&this.isReady){if(e){const e={maximizable:!1};return this.updateState(e,f.SERVICE)}if(this._currentState.maximizable!==this._applicationState.maximizable){const e={maximizable:!0};return this.updateState(e,f.SERVICE)}}return Promise.resolve()}async sync(){let e=0;for(;this._pendingActions.length>0;){if(!(++e<=10))return Promise.reject(new Error(`Couldn't sync ${this._id} after ${e} attempts`));await Promise.all(this._pendingActions)}}refresh(){const e=this._window;return this.isReady?b.getWindowState(e).then(e=>{const t=this._applicationState,i={};let n=!1;return u.forEachProperty(e,s=>{!this.isModified(s,t,e)||this._modifiedState.hasOwnProperty(s)&&!this.isModified(s,this._modifiedState,e)||(i[s]=e[s],n=!0)}),n?(console.log("Window refresh found changes: ",this._id,i),this.updateState(i,f.APPLICATION)):(console.log("Refreshed window, no changes were found",this._id),Promise.resolve())}):Promise.resolve()}async bringToFront(){return this.addPendingActions("bringToFront "+this._id,this._window.bringToFront())}async setAsForeground(){return this.addPendingActions("setAsForeground "+this._id,this._window.setAsForeground())}async close(){return this._lifecycleStage=g.ENDING,this.addPendingActions("close "+this._id,this._window.close(!0))}async applyProperties(e){this.updateState(e,f.SERVICE)}async applyOverride(e,t){if(t!==this._currentState[e])return this.updateState({[e]:t},f.SERVICE_TEMPORARY)}async resetOverride(e){if(this._temporaryState.hasOwnProperty(e)){const t=this._temporaryState[e];return this._currentState[e]=t,this.updateState({[e]:t},f.SERVICE)}}async sendEvent(e){if(this._lifecycleStage===g.STARTING&&await this.sync(),this.isReady&&d.apiHandler.isClientConnection(this.identity))return d.apiHandler.sendToClient(this._identity,a.EVENT_CHANNEL_TOPIC,e)}async addPendingActions(e,t){return t instanceof Array?(this._pendingActions.push.apply(this._pendingActions,t),t.forEach((i,n)=>{this._actionTags.set(i,`${e} (${n+1} of ${t.length})`),i.then(this.onActionComplete.bind(this,i))}),t.length>1?Promise.all(t).then(()=>{}):1===t.length?t[0]:void 0):(this._pendingActions.push(t),this._actionTags.set(t,e),t.then(this.onActionComplete.bind(this,t)),t)}onActionComplete(e){const t=this._pendingActions.indexOf(e);t>=0?this._pendingActions.splice(t,1):console.warn("Action completed but couldn't find it in pending action list")}cloneState(e){return Object.assign({center:Object.assign({},e.center),halfSize:Object.assign({},e.halfSize),resizeConstraints:{x:Object.assign({},e.resizeConstraints.x),y:Object.assign({},e.resizeConstraints.y)}},e)}isModified(e,t,i){if(void 0===t[e])return!0;if("center"===e||"halfSize"===e){const n=t[e],s=i[e];return n.x!==s.x||n.y!==s.y}if("resizeConstraints"===e){const n=t[e],s=i[e];return["x","y"].some(e=>{const t=n[e],i=s[e];return t.minSize!==i.minSize||t.maxSize!==i.maxSize||t.resizableMin!==i.resizableMin||t.resizableMax!==i.resizableMax})}return t[e]!==i[e]}snap(){const e=this._snapGroup,t=this._snapGroup.windows,i=t.length,n=t.indexOf(this);if(i>=2&&n>=0&&this.isReady){const i=t[0===n?1:0];return Promise.all([this.sync(),i.sync()]).then(()=>{const t=(async()=>{if(this.isReady&&e===this._snapGroup){let t;if(!(t=i.isReady?i:e.windows.find(e=>e.isReady&&e!==this)))return void console.warn("Found no ready windows when attempting to group window ",this.id);const n=this._snapGroup.windows;await n.map(e=>{e.isReady?e._window.bringToFront():console.warn("groupWindow is not ready. You may have a non-existent window in your snapGroup: ",e)})}})();return this.addPendingActions("snap - joinGroup",t)})}return-1===n?Promise.reject(new Error("Attempting to snap, but window isn't in the target group")):Promise.reject(new Error("Need at least 2 windows in group to snap"))}checkClose(e){if(e){if(!e.message.includes("Could not locate the requested window"))throw e;this._lifecycleStage=g.ENDING}}unsnap(){return this.isReady?this._window.leaveGroup():Promise.resolve()}addToSnapGroup(e){this._prevGroup=this._snapGroup,this._snapGroup=e,e.addWindow(this)}async updateState(e,t){const i=[];if(t!==f.APPLICATION&&!this.isReady)throw new Error("Cannot modify window, window not in ready state "+this._id);t===f.APPLICATION?u.forEachProperty(e,t=>{this.isModified(t,e,this._currentState)&&("object"==typeof e[t]?Object.assign(this._applicationState[t],e[t]):this._applicationState[t]=e[t])}):u.forEachProperty(e,t=>{this.isModified(t,e,this._applicationState)?this._modifiedState[t]=e[t]:delete this._modifiedState[t]}),t===f.SERVICE_TEMPORARY?u.forEachProperty(e,e=>{this._temporaryState.hasOwnProperty(e)||(this._temporaryState[e]=this._currentState[e])}):u.forEachProperty(e,e=>{this._temporaryState.hasOwnProperty(e)&&delete this._temporaryState[e]});const s=this._currentState.state,o=this._currentState.resizeConstraints;if(Object.assign(this._currentState,e),t!==f.APPLICATION){const t=this._window,{center:r,halfSize:a,state:d,hidden:c,resizeConstraints:l}=e,u=n(e,["center","halfSize","state","hidden","resizeConstraints"]),p=Object.keys(u);if(void 0!==c&&i.push(c?t.hide():t.show()),void 0!==d&&d!==s)switch(d){case"normal":i.push(t.restore());break;case"minimized":i.push(t.minimize());break;case"maximized":i.push(t.maximize());break;default:console.warn("Invalid window state: "+d)}if(r||a){const e=this._currentState;let n=r||e.center,s=a||e.halfSize;h.isWin10()&&e.frame&&(n={x:n.x,y:n.y+3.5},s={x:s.x+7,y:s.y+3.5});const o={left:n.x-s.x,top:n.y-s.y,width:2*s.x,height:2*s.y};i.push(t.setBounds(o))}if(l){const e=l.x.maxSize===Number.MAX_SAFE_INTEGER?o.x.maxSize===Number.MAX_SAFE_INTEGER?void 0:-1:l.x.maxSize,n=l.y.maxSize===Number.MAX_SAFE_INTEGER?o.y.maxSize===Number.MAX_SAFE_INTEGER?void 0:-1:l.y.maxSize;i.push(t.updateOptions({resizable:l.x.resizableMin||l.x.resizableMax||l.y.resizableMin||l.y.resizableMax,resizeRegion:{sides:{left:l.x.resizableMin,right:l.x.resizableMax,top:l.y.resizableMin,bottom:l.y.resizableMax}},minWidth:l.x.minSize,minHeight:l.y.minSize,maxWidth:e,maxHeight:n}))}return p.length>0&&i.push(t.updateOptions(u)),this.addPendingActions("updateState "+this._id+" "+JSON.stringify(e),i)}}checkBounds(e){return h.isWin10()&&this._currentState.frame?{left:e.left+7,top:e.top,width:e.width-14,height:e.height-7}:e}addListeners(){this.registerListener("begin-user-bounds-changing",this.handleBeginUserBoundsChanging.bind(this)),this.registerListener("bounds-changed",this.handleBoundsChanged.bind(this)),this.registerListener("bounds-changing",this.handleBoundsChanging.bind(this)),this.registerListener("closing",this.handleClosing.bind(this)),this.registerListener("focused",this.handleFocused.bind(this)),this.registerListener("group-changed",this.handleGroupChanged.bind(this)),this.registerListener("hidden",()=>this.updateState({hidden:!0},f.APPLICATION)),this.registerListener("maximized",()=>{this.updateState({state:"maximized"},f.APPLICATION),this.snapGroup.validate()}),this.registerListener("minimized",()=>{this.updateState({state:"minimized"},f.APPLICATION),this._snapGroup.windows.forEach(e=>{e===this||e.currentState.hidden||e.applyProperties({state:"minimized"})})}),this.registerListener("restored",()=>{this.updateState({state:"normal"},f.APPLICATION),this._snapGroup.windows.forEach(e=>{e===this||e.currentState.hidden||e.applyProperties({state:"normal"})})}),this.registerListener("shown",()=>this.updateState({hidden:!1},f.APPLICATION))}registerListener(e,t){this._window.addListener(e,t),this._registeredListeners.set(e,t)}cleanupListeners(){const e=this._window;for(const[t,i]of this._registeredListeners)e.removeListener(t,i);this._registeredListeners.clear()}handleBoundsChanged(e){this._moveInProgress=!1;const t=this.checkBounds(e),i={x:t.width/2,y:t.height/2},n={x:t.left+i.x,y:t.top+i.y};let s;this._userInitiatedBoundsChange&&(s=this.updateTransformType(e,this._userInitiatedBoundsChange)),this.updateState({center:n,halfSize:i},f.APPLICATION),this._userInitiatedBoundsChange?(this.onCommit.emit(this,s),this._model.displayScaling&&this._snapGroup.restoreResizeConstraints(),this._userInitiatedBoundsChange=null):this.onModified.emit(this)}handleBoundsChanging(e){this._moveInProgress||(this._moveInProgress=!0);const t=this.checkBounds(e),i={x:t.width/2,y:t.height/2},n={x:t.left+i.x,y:t.top+i.y};let s;this._userInitiatedBoundsChange&&(s=this.updateTransformType(e,this._userInitiatedBoundsChange)),this.updateState({center:n,halfSize:i},f.APPLICATION),this._userInitiatedBoundsChange&&this.onTransform.emit(this,s)}updateTransformType(e,t){if(this._model.displayScaling){const i=t.transformType,n=t.startBounds,s=this.checkBounds(e),o={x:s.width/2,y:s.height/2},r={x:s.left+o.x,y:s.top+o.y},a=e=>{const t=2*Math.abs(o[e]-n.halfSize[e])>m;let i;if(t){const t=Math.sign(o[e]-n.halfSize[e])*(Math.sign(r[e]-n.center[e])||1);i=n.center[e]+t*(o[e]-n.halfSize[e])}else i=n.center[e];return(Math.abs(i-r[e])>y?w.MOVE:0)|(t?w.RESIZE:0)};t.transformType|=a("x"),t.transformType|=a("y"),t.transformType&w.MOVE&&(t.transformType=w.MOVE);const d=t.transformType;return d===w.MOVE&&i!==w.MOVE?this._snapGroup.suspendResizeConstraints():d!==w.MOVE&&i===w.MOVE&&this._snapGroup.restoreResizeConstraints(),d}return e.changeType+1}handleBeginUserBoundsChanging(e){const t={center:Object.assign({},this.currentState.center),halfSize:Object.assign({},this.currentState.halfSize)};this._userInitiatedBoundsChange={startBounds:t,transformType:0},this.updateTransformType(e,this._userInitiatedBoundsChange);let i=!1;const n=()=>{i=!0};this._window.once("disabled-frame-bounds-changing",n),this._window.once("bounds-changed",()=>{!i&&this._snapGroup.length>1&&(this._tabGroup?this._tabGroup.validate():this._snapGroup.validate()),this._window.removeListener("disabled-frame-bounds-changing",n)})}handleClosing(){this._lifecycleStage=g.ENDING,this.teardown()}async handleFocused(){this.isMaximizedOrInMaximizedTab()?this._tabGroup&&"maximized"===this._tabGroup.state&&this._snapGroup.windows.filter(e=>e!==this&&e._tabGroup===this._tabGroup).forEach(e=>e.bringToFront()):this._snapGroup.windows.filter(e=>e!==this&&!e.isMaximizedOrInMaximizedTab()&&!e.currentState.hidden).forEach(e=>e.bringToFront())}async handleGroupChanged(e){if(e.name!==e.sourceWindowName||e.uuid!==e.sourceWindowAppUuid)return;await this.sync();const t=this._model.getWindow({uuid:e.targetWindowAppUuid,name:e.targetWindowName}),i=t?t.snapGroup:null,n=b.activeTransactions.filter(e=>e.windows.some(e=>!!t&&e._id===t._id));if(n.length>0)return console.log("Window currently in a transaction. Ignoring window group changed event: ",e),void n.forEach(e=>{e.remove.postpone()});switch(console.log("Received window group changed event: ",e),e.reason){case"leave":{const t=e.sourceGroup.concat({appUuid:this._identity.uuid,windowName:this._identity.name});return this._snapGroup.length>1&&s(this._snapGroup.windows,t)?this.setSnapGroup(new p.DesktopSnapGroup):Promise.resolve()}case"join":if(t&&i)return s(this._snapGroup.windows,e.targetGroup)?Promise.resolve():this.addToSnapGroup(i);break;case"merge":t&&i&&this._snapGroup.windows.forEach(e=>e.setSnapGroup(i));break;case"disband":break;default:console.warn("Received unexpected group event type: "+e.reason+'. Expected valued are "leave", "join", "merge" or "disband".')}function s(e,t){return o.default(e.map(e=>e.identity).sort((e,t)=>e.uuid===t.uuid?e.name.localeCompare(t.name):e.uuid.localeCompare(t.uuid)),t.map(e=>({uuid:e.appUuid,name:e.windowName})).sort((e,t)=>e.uuid===t.uuid?e.name.localeCompare(t.name):e.uuid.localeCompare(t.uuid)))}}isMaximizedOrInMaximizedTab(){return"maximized"===this._currentState.state||null!==this._tabGroup&&"maximized"===this._tabGroup.state}}b.onCreated=new c.Signal1,b.onDestroyed=new c.Signal1,b.activeTransactions=[],t.DesktopWindow=b},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(1),s=i(2),o=i(5),r=i(18),a=i(39);var d;!function(e){e.TAB="TAB",e.SNAP="SNAP",e.EJECT="EJECT"}(d=t.eTargetType||(t.eTargetType={}));t.WindowHandler=class{constructor(e){this.view=new a.View(e),r.DragWindowManager.onDragOver.add(this.onTabDrag,this),r.DragWindowManager.onDragDrop.add(this.onTabDrop,this),s.DesktopSnapGroup.onCreated.add(this.onSnapGroupCreated,this),s.DesktopSnapGroup.onDestroyed.add(this.onSnapGroupDestroyed,this)}onSnapGroupCreated(e){e.onTransform.add(this.onGroupTransform,this),e.onCommit.add(this.onGroupCommit,this)}onSnapGroupDestroyed(e){e.onTransform.remove(this.onGroupTransform,this),e.onCommit.remove(this.onGroupCommit,this)}onGroupTransform(e,t){const i=this.getTarget(e,t);this.view.update(i)}onGroupCommit(e,t){const i=this.getTarget(e,t);this.view.update(null),i&&i.valid&&(i.type===d.TAB?n.tabService.applyTabTarget(i):i.type===d.SNAP&&n.snapService.applySnapTarget(i))}onTabDrag(e,t){const i=n.tabService.getTarget(e);this.view.update(i)}onTabDrop(e){this.view.update(null);const t=n.tabService.getTarget(e);t&&t.valid&&n.tabService.applyTabTarget(t)}getTarget(e,t){const i=n.snapService.getTarget(e),s=0==(t&o.eTransformType.RESIZE)?n.tabService.getTarget(e.windows[0]):null;return i||s}}},,function(e,t,i){"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.service=0]="service",e[e.desktop=1]="desktop",e[e.application=2]="application",e[e.window=3]="window"}(n=t.ScopePrecedence||(t.ScopePrecedence={}));class s{static getId(e){switch(e.level){case"application":return`${e.level}:${s.stringifyParam(e.uuid)}`;case"window":return`${e.level}:${s.stringifyParam(e.uuid)}/${s.stringifyParam(e.name)}`;default:return e.level}}static scopesEqual(e,t){if(e.level!==t.level)return!1;switch(e.level){case"application":return e.uuid===t.uuid;case"window":return e.uuid===t.uuid&&e.name===t.name;default:return!0}}static rulesEqual(e,t){function i(e,t){return typeof e==typeof t&&("string"==typeof e?e===t:"string"!=typeof t&&(e.expression===t.expression&&(e.flags||"")===(t.flags||"")&&(e.invert||!1)===(t.invert||!1)))}if(e.level!==t.level)return!1;switch(e.level){case"application":return i(e.uuid,t.uuid);case"window":return i(e.uuid,t.uuid)&&i(e.name,t.name);default:return!0}}static matchesScope(e,t){const i=n[e.level],s=n[t.level];return i!==s?i<s:this.scopesEqual(e,t)}static ruleCanBeAddedInScope(e,t){return n[e.level]>=n[t.level]}static ruleCanBeUsedInScope(e,t){return n[e.level]<=n[t.level]}static matchesRule(e,t){if(!this.ruleCanBeUsedInScope(e,t))return console.warn(`No way that a "${t.level}" scope can pass a "${e.level}" rule`),!1;switch(e.level){case"window":{const i=t;return!!this.checkPattern(e.name,i.name)&&!(e.uuid&&!this.checkPattern(e.uuid,i.uuid))}case"application":{const i=t;return!(e.uuid&&!this.checkPattern(e.uuid,i.uuid))}default:return!0}}static checkPattern(e,t){if(e){if("string"==typeof e)return e===t;return new RegExp(e.expression,e.flags).test(t)===!e.invert}return!0}static deepCopy(e){if(e instanceof Object){const t=Object.assign({},e);for(const e in t)t[e]instanceof Object&&(t[e]=s.deepCopy(t[e]));return t}return e}static deepAssign(e,t){for(const i in t)e.hasOwnProperty(i)?e[i]instanceof Object?s.deepAssign(e[i],t[i]):e[i]=t[i]:e[i]=s.deepCopy(t[i])}static deepAssignMask(e,t,i){const n=Object.keys(i instanceof Object?i:t);if(!1!==i)for(const o of n)t.hasOwnProperty(o)&&s.inMask(i,o)&&s.assignProp(e,t,o,i)}static containsConfig(e){for(const t in e)if("rules"!==t)return!0;return!1}static matchesMask(e,t){if(t instanceof Object){const i=t;return Object.keys(t).findIndex(n=>{const s=typeof i[n];return"boolean"===s?i[n]&&e.hasOwnProperty(n):"object"===s?!!e.hasOwnProperty(n)&&this.matchesMask(e[n],i[n]):(console.warn("Unexpected value found within mask:",t,n),!1)})>=0}return"boolean"==typeof t?t:(console.warn("Unexpected value found within mask:",t,"when applying mask to",e),!1)}static stringifyParam(e){return"string"==typeof e?e:`${e.invert?"!":""}/${e.expression}/${e.flags||""}`}static assignProp(e,t,i,n){t[i]instanceof Object?t[i]&&(e.hasOwnProperty(i)||(e[i]={}),s.deepAssignMask(e[i],t[i],"object"==typeof n?n[i]:n)):e[i]=t[i]}static inMask(e,t){return"boolean"==typeof e?e:"object"==typeof e[t]||!0===e[t]}}t.ConfigUtil=s},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});i(0);var n;function s(e,t,i){return t===e}t.EVENT_CHANNEL_TOPIC="event",function(e){e[e.NO_WINDOW=0]="NO_WINDOW",e[e.NO_TAB_GROUP=1]="NO_TAB_GROUP",e[e.UNEXPECTED=2]="UNEXPECTED"}(n=t.ErrorType||(t.ErrorType={})),t.getErrorMessage=function(e,t){return s(n.NO_WINDOW,e,t)?`Cannot find window ${t.uuid}/${t.name}.  It may be deregistered.`:s(n.NO_TAB_GROUP,e,t)?`Cannot find tab group for window ${t.uuid}/${t.name}.`:s(n.UNEXPECTED,e,t)?`Unexpected error when ${t.action}: ${t.error}`:"Unknown Error"}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(1),s=i(11),o=i(15),r=i(3),a=i(2),d=i(20),c=i(5);class l{constructor(e,t,i){const n=l.windowPool,s=n.getNextWindow(i)||n.generateTabStripOptions(i);this._model=e,this._activeTab=null,this._window=new c.DesktopWindow(e,s),this._window.onModified.add(e=>this.updateBounds()),this._window.onTransform.add((e,t)=>this.updateBounds()),this._window.onCommit.add((e,t)=>this.updateBounds()),this._window.onTeardown.add(e=>this.onTabGroupTeardown()),this._groupState=Object.assign({},this._window.currentState),this._tabs=[],this._config=i,this._window.setTabGroup(this),this._window.setSnapGroup(t),this._isMaximized=!1,this._validateGroup=new o.Debounced(this.validateGroupInternal,this),this._closingOnTabRemoval=!1,l.onCreated.emit(this)}static get windowPool(){return this._windowPool||(this._windowPool=new d.DesktopTabstripFactory),this._windowPool}get id(){return this._window.id}get identity(){return this._window.identity}get currentState(){return this.updateBounds(),this._groupState}get snapGroup(){return this._window.snapGroup}get tabGroup(){return this}get config(){return this._config}get activeTab(){return this._activeTab||this._tabs[0]}get window(){return this._window}get tabs(){return this._tabs}get scope(){return(this._activeTab||this._tabs[0]||this._window).scope}get state(){return"minimized"===this._window.currentState.state?"minimized":this._isMaximized?"maximized":"normal"}applyOverride(e,t){return this.updateWindows(i=>i.applyOverride(e,t))}resetOverride(e){return this.updateWindows(t=>t.resetOverride(e))}async setSnapGroup(e){const t=this._tabs.concat(this._window);return Promise.all(t.map(t=>t.setSnapGroup(e))).then(()=>{})}async applyOffset(e,t){const i=this._config.height/2,n=t&&{x:t.x,y:t.y-i};if(this._model.displayScaling){const s=t&&{x:t.x,y:i};return c.DesktopWindow.transaction([this._window,...this.tabs],async t=>{await this._window.applyOffset(e,s);for(const t of this.tabs)await t.applyOffset(e,n)})}return this.activeTab.applyOffset(e,n)}async toggleMaximize(){return this._isMaximized?this.restore():this.maximize()}async maximize(){if(!this.currentState.maximizable){const e=this._tabs.filter(e=>!e.applicationState.maximizable).map(e=>e.id),t=this._tabs.filter(e=>{const t=e.applicationState.resizeConstraints;return t.x.maxSize<Number.MAX_SAFE_INTEGER||t.y.maxSize<Number.MAX_SAFE_INTEGER}).map(e=>e.id);throw e.length>0?new Error(`Unable to maximize tabGroup: The following tabs are not resizable: [${e.join(", ")}]`):t.length>0?new Error(`Unable to maximize tabGroup: The following tabs have maximum size constraints: [${t.join(", ")}]`):new Error("Unable to maximize tabGroup: Group is not maximizable")}if(!this._isMaximized){this.snapGroup.isNonTrivial()&&await this.setSnapGroup(new a.DesktopSnapGroup);const{center:e,halfSize:t}=this._activeTab&&this._activeTab.currentState||this._tabs[0].currentState;this._beforeMaximizeBounds={center:Object.assign({},e),halfSize:Object.assign({},t)};const i=this._model.getMonitorByRect(this._groupState)||this._model.monitors[0];await this._window.applyProperties({center:{x:i.center.x,y:this._config.height/2},halfSize:{x:i.halfSize.x,y:this._config.height/2}}),await this.activeTab.applyProperties({center:{x:i.center.x,y:i.center.y+this._config.height/2},halfSize:{x:i.halfSize.x,y:i.halfSize.y-this._config.height/2}}),this._isMaximized=!0;const n={identity:this.window.identity,type:"tab-group-maximized"};this.window.sendEvent(n)}}async restore(){if("minimized"===this.state){const e=this.window.applyProperties({state:"normal"}),t={identity:this.window.identity,type:"tab-group-restored"};return this.window.sendEvent(t),e}{if(this._isMaximized){if("minimized"===this.activeTab.currentState.state)await Promise.all(this._tabs.map(e=>e.applyProperties({state:"normal"})));else if(this._beforeMaximizeBounds){this._isMaximized=!1;const e=this._beforeMaximizeBounds;await this._window.applyProperties({center:{x:e.center.x,y:e.center.y-e.halfSize.y-this._config.height/2},halfSize:{x:e.halfSize.x,y:this._config.height/2}}),await this.activeTab.applyProperties(e)}}else await Promise.all(this._tabs.map(e=>e.applyProperties({state:"normal"})));const e={identity:this.window.identity,type:"tab-group-restored"};this.window.sendEvent(e)}}async minimize(){await Promise.all([this._window.applyProperties({state:"minimized"}),this.activeTab.applyProperties({state:"minimized"})]);const e={identity:this.window.identity,type:"tab-group-minimized"};this.window.sendEvent(e)}async closeAll(){return this.removeAllTabs(!0)}async addTab(e){await this.addTabInternal(e,!0)}async addTabAt(e,t){await this.addTabInternal(e,!0,t)}async addTabs(e,t){const i=e.concat(this._window),n=e.shift(),s=t&&this._model.getWindow(t)||n;let o;if(0===this.tabs.length&&"maximized"===n.currentState.state){const e=n.beforeMaximizeBounds,t={x:e.center.x,y:e.center.y+this._config.height/2},i={x:e.halfSize.x,y:e.halfSize.y-this._config.height/2};o={center:t,halfSize:i}}await c.DesktopWindow.transaction(i,async()=>{await this.addTabInternal(n,!1),await Promise.all([n.sync(),this._window.sync()]);for(const t of e)await this.addTabInternal(t,s===t)}),await this.switchTab(s),o&&await this.maximize().then(()=>{this._beforeMaximizeBounds=o},()=>{})}async swapTab(e,t){if(!(this._tabs.indexOf(e)>=0))throw new Error(`Cannot swap tabs - ${e&&e.id} doesn't exist within tab set`);await this.addTabInternal(t,!1,this._tabs.indexOf(e)+1),await this.removeTabInternal(e,this._tabs.indexOf(e)),this._activeTab&&this._activeTab.id===e.id?this.switchTab(t):t.applyProperties({hidden:!0})}reorderTabArray(e){const t=e.map(e=>{const t=this._model.getId(e);return this._tabs.find(e=>e.id===t)}).filter(e=>void 0!==e);if(t.length!==this._tabs.length)throw new Error("Input array must reference each tab exactly once");this._tabs=t}async removeTab(e,t){const i=this._tabs.indexOf(e);if(e&&i>=0){const n=[],s=this._tabs.slice(),o=this.snapGroup.entities;if(n.push(this.removeTabInternal(e,i)),e.isReady){const{frame:i,resizeConstraints:s}=e.applicationState;if(t)n.push(e.applyProperties(Object.assign({hidden:!1,frame:i,resizeConstraints:s},t)));else if(null===t)n.push(e.applyProperties({hidden:!1,frame:i,resizeConstraints:s}));else{const t=this._window.currentState.halfSize,o=e.currentState,r={x:o.center.x,y:o.center.y-t.y},a={x:o.halfSize.x,y:o.halfSize.y+t.y};n.push(e.applyProperties({hidden:!1,frame:i,resizeConstraints:s,center:r,halfSize:a}))}}if(this._tabs.length>=2&&this.activeTab.id===e.id){const e=this._tabs[i]?this._tabs[i]:this._tabs[i-1];n.push(this.switchTab(e))}if(await Promise.all(n),2===s.length&&o.length>1){const t=o[0]===this?o[1]:o[0],i=s[0]===e?s[1]:s[0];await new Promise(e=>setTimeout(e,10)),i.isReady&&(console.log("Re-attaching remaining tab: "+i.id+" => "+t.id),await i.setSnapGroup(t.snapGroup))}}}async switchTab(e){if(e&&e!==this._activeTab){const t=this._activeTab,i=this._activeTab&&(this._tabs.indexOf(this._activeTab)>=0||!this._activeTab.isReady);this._activeTab=e;const n="minimized"===this.state?"minimized":"normal";await e.applyProperties({hidden:!1,state:n}),await new Promise(e=>setTimeout(e,75)),i&&await e.setAsForeground(),t&&t.tabGroup===this&&await t.applyProperties({hidden:!0,state:"normal"}),await Promise.all([this._window.sync(),e.sync()]).catch(e=>console.error(e));const s={tabstripIdentity:this.identity,identity:e.identity,type:"tab-activated"};this._window.sendEvent(s)}}removeAllTabs(e){const t=this._tabs.slice();let i;return i=e?t.map(e=>e.close()):t.map(e=>this.removeTab(e)),Promise.all(i).then(()=>{})}validate(){this._validateGroup.call()}getSaveDimensions(){if(this._isMaximized&&this._beforeMaximizeBounds){const e=this._beforeMaximizeBounds;return{x:e.center.x-e.halfSize.x,y:e.center.y-e.halfSize.y-this._config.height,width:2*e.halfSize.x,appHeight:2*e.halfSize.y}}{const e=this.activeTab.currentState,t=this.window.currentState;return{x:t.center.x-t.halfSize.x,y:t.center.y-t.halfSize.y,width:2*t.halfSize.x,appHeight:2*e.halfSize.y}}}updateBounds(){const e=this.activeTab;if(!e)return void console.warn(`No tabs for group ${this.id}`,new Error);const t=this._groupState,i=e.currentState,n=this._window.currentState;t.center.x=n.center.x,t.halfSize.x=n.halfSize.x,t.center.y=i.center.y-n.halfSize.y,t.halfSize.y=i.halfSize.y+n.halfSize.y}onTabTransform(e,t){this.updateBounds()}updateWindows(e){const t=this._tabs.map(e);return t.concat(e(this._window)),Promise.all(t).then(()=>{})}async addTabInternal(e,t,i=this._tabs.length){let s=null;const o=e.tabGroup;if(o===this)return;if(o&&(console.info("Existing tab attempting to be added. Removing tab from previous group..."),s=o.removeTab(e)),this._tabs.splice(i,0,e),e.onTeardown.add(this.onWindowTeardown,this),e.onTransform.add(this.onTabTransform,this),s?await Promise.all([this._window.sync(),e.sync(),s]):await Promise.all([this._window.sync(),e.sync()]),e.snapGroup.isNonTrivial()&&await e.setSnapGroup(new a.DesktopSnapGroup),1===this._tabs.length){const t=e.currentState;await this._window.applyProperties({center:{x:t.center.x,y:t.center.y-t.halfSize.y+this._config.height/2},halfSize:{x:t.halfSize.x,y:this._config.height/2},hidden:!1});const i={x:t.center.x,y:t.center.y+this._config.height/2},n={x:t.halfSize.x,y:t.halfSize.y-this._config.height/2};await e.applyProperties({center:i,halfSize:n,frame:!1})}else{await new Promise(e=>setTimeout(e,10)),this._window.moveInProgress&&await new Promise(async e=>{const t=this._window.onCommit.add(async(i,n)=>{t.remove(),e()})});const t=this._activeTab&&this._activeTab.currentState||this._tabs[0].currentState,{center:i,halfSize:n}=t;await e.applyProperties({center:i,halfSize:n,frame:!1})}await e.setTabGroup(this),await e.setSnapGroup(this._window.snapGroup);const r=n.tabService.getTabProperties(e),d={tabstripIdentity:this.identity,identity:e.identity,properties:r,index:this._tabs.indexOf(e),type:"tab-added"};this.sendTabEvent(e,d),t?await this.switchTab(e):await e.applyProperties({hidden:!0}),await Promise.all([e.sync(),this._window.sync()]),await this.updateGroupConstraints()}async removeTabInternal(e,t){if(this._tabs.splice(t,1),e.onTeardown.remove(this.onWindowTeardown,this),e.onTransform.remove(this.onTabTransform,this),e.isReady){const t=e.setTabGroup(null),i=e.setSnapGroup(new a.DesktopSnapGroup);await Promise.all([t,i])}else await e.setTabGroup(null);await this.updateGroupConstraints();const i={tabstripIdentity:this.identity,identity:e.identity,type:"tab-removed"};if(await this.sendTabEvent(e,i),this._tabs.length<2){if(this._window.isReady){this._closingOnTabRemoval=!0;const e=this._window.close(),t=this._tabs.map(async e=>{await e.refresh(),await this.removeTab(e)});await Promise.all(t.concat(e))}this._window.setTabGroup(null),l.onDestroyed.emit(this)}}async onTabGroupTeardown(){if(!this._closingOnTabRemoval)return this.removeAllTabs(!0)}async onWindowTeardown(e){this._tabs.indexOf(e)>=0&&(e.isReady?await this.removeTab(e):await this.removeTab(e,null))}async sendTabEvent(e,t){await Promise.all([e.sendEvent(t),this._window.sendEvent(t)])}async updateGroupConstraints(){const e={x:{minSize:0,maxSize:Number.MAX_SAFE_INTEGER,resizableMin:!0,resizableMax:!0},y:{minSize:0,maxSize:Number.MAX_SAFE_INTEGER,resizableMin:!0,resizableMax:!0}};for(const t of this.tabs){let i;for(i in e)if(e.hasOwnProperty(i)){const n=t.applicationState.resizeConstraints[i];e[i]={minSize:Math.max(e[i].minSize,n.minSize),maxSize:Math.min(e[i].maxSize,n.maxSize),resizableMin:e[i].resizableMin&&n.resizableMin,resizableMax:e[i].resizableMax&&n.resizableMax}}}this.currentState.resizeConstraints={x:Object.assign({},e.x),y:Object.assign({},e.y)},this._window.isReady&&await this._window.applyProperties({resizeConstraints:{x:e.x,y:{minSize:this._config.height,maxSize:this._config.height,resizableMin:e.y.resizableMin,resizableMax:!1}}}),e.y.resizableMin=!1,await Promise.all(this.tabs.map(t=>t.applyProperties({resizeConstraints:e}))),this._groupState.maximizable=this._tabs.every(e=>e.applicationState.maximizable)&&e.x.maxSize===Number.MAX_SAFE_INTEGER&&e.y.maxSize===Number.MAX_SAFE_INTEGER}async validateGroupInternal(){const e={center:{x:this.activeTab.currentState.center.x,y:this.activeTab.currentState.center.y-this.activeTab.currentState.halfSize.y-this.config.height/2},halfSize:{x:this.activeTab.currentState.halfSize.x,y:this._config.height/2}};r.RectUtils.isEqual(e,this._window.currentState)||(console.log("TabGroup disjointed. Moving tabstrip back to group.",this.id),await c.DesktopWindow.transaction([this._window],async t=>{await t[0].applyProperties(e)}))}}l.onCreated=new s.Signal1,l.onDestroyed=new s.Signal1,t.DesktopTabGroup=l},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.Aggregators=class{static ARRAY(e){return e}static AWAIT(e){return Promise.all(e)}static async AWAIT_VOID(e){await Promise.all(e)}};class n{constructor(e,t){this._length=e,this._slots=[],this.aggregator=t||null}get length(){return this._length}get slots(){return this._slots}addInternal(e,t){if(e.length===this._length){const i={callback:e,context:t,remove:()=>this.removeSlot(i)};return this._slots.push(i),i}throw new Error("Callback function must accept "+this._length+" arguments")}removeInternal(e,t){const i=this._slots.findIndex(i=>i.callback===e&&i.context===t);return i>=0&&(this._slots.splice(i,1),!0)}hasInternal(e,t){return this._slots.findIndex(i=>i.callback===e&&i.context===t)>=0}emitInternal(...e){const t=this._slots.slice();return this.aggregator?this.aggregator(t.map(t=>t.callback.apply(t.context,e))):void t.forEach(t=>t.callback.apply(t.context,e))}removeSlot(e){const t=this._slots.indexOf(e);t>=0&&this._slots.splice(t,1)}}t.Signal0=class extends n{constructor(e){super(0,e)}add(e,t){return super.addInternal(e,t)}remove(e,t){return super.removeInternal(e,t)}has(e,t){return super.hasInternal(e,t)}emit(){return super.emitInternal()}};t.Signal1=class extends n{constructor(e){super(1,e)}add(e,t){return super.addInternal(e,t)}remove(e,t){return super.removeInternal(e,t)}has(e,t){return super.hasInternal(e,t)}emit(e){return super.emitInternal(e)}};t.Signal2=class extends n{constructor(e){super(2,e)}add(e,t){return super.addInternal(e,t)}remove(e,t){return super.removeInternal(e,t)}has(e,t){return super.hasInternal(e,t)}emit(e,t){return super.emitInternal(e,t)}};t.Signal3=class extends n{constructor(e){super(3,e)}add(e,t){return super.addInternal(e,t)}remove(e,t){return super.removeInternal(e,t)}has(e,t){return super.hasInternal(e,t)}emit(e,t,i){return super.emitInternal(e,t,i)}};t.Signal4=class extends n{constructor(e){super(4,e)}add(e,t){return super.addInternal(e,t)}remove(e,t){return super.removeInternal(e,t)}has(e,t){return super.hasInternal(e,t)}emit(e,t,i,n){return super.emitInternal(e,t,i,n)}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SNAP_DISTANCE=15,t.ANCHOR_DISTANCE=100,t.MIN_OVERLAP=50,t.ADJACENCY_FUZZ_DISTANCE=2,t.UNDOCK_MOVE_DISTANCE=0,t.EXPLODE_MOVE_SCALE=.1},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.promiseMap=async function(e,t){return Promise.all(e.map(t))},t.promiseFilter=async function(e,t){const i=[];for(let n=0;n<e.length;n++)await t(e[n])&&i.push(e[n]);return i},t.promiseForEach=async function(e,t){for(let i=0;i<e.length;i++)await t(e[i])}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(29),s=i(8);class o{constructor(e){this.onAdd=new n.Signal2,this.onRemove=new n.Signal2,this._store=e,e.addWatch(this)}get store(){return this._store}remove(){this._store.removeWatch(this)}}t.Watch=o;t.ScopeWatch=class extends o{constructor(e,t){super(e),this.type="scope",this.scope=t}matches(e){return s.ConfigUtil.ruleCanBeUsedInScope(e.scope,this.scope)&&s.ConfigUtil.matchesRule(e.scope,this.scope)}};t.MaskWatch=class extends o{constructor(e,t){super(e),this.type="mask",this.mask=t}matches(e){return s.ConfigUtil.matchesMask(e.config,this.mask)}};t.SourceWatch=class extends o{constructor(e,t){super(e),this.type="source",this.source=t}matches(e){return s.ConfigUtil.ruleCanBeUsedInScope(this.source,e.source)&&s.ConfigUtil.matchesRule(this.source,e.source)}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class n{constructor(e,t){this.callback=e,this.scope=t,this.handle=-1,this.onTimeout=this.onTimeout.bind(this)}call(...e){this.args=e,this.schedule()}postpone(){this.handle>=0&&this.schedule()}onTimeout(){const e=this.args;delete this.args,this.handle=-1,this.callback.apply(this.scope,e)}cancel(){this.handle>=0&&clearTimeout(this.handle)}schedule(){this.cancel(),this.handle=setTimeout(this.onTimeout,n.DEBOUNCE_INTERVAL)}}n.DEBOUNCE_INTERVAL=200,t.Debounced=n},function(e,t,i){"use strict";var n=Array.isArray,s=Object.keys,o=Object.prototype.hasOwnProperty;e.exports=function e(t,i){if(t===i)return!0;if(t&&i&&"object"==typeof t&&"object"==typeof i){var r,a,d,c=n(t),l=n(i);if(c&&l){if((a=t.length)!=i.length)return!1;for(r=a;0!=r--;)if(!e(t[r],i[r]))return!1;return!0}if(c!=l)return!1;var h=t instanceof Date,u=i instanceof Date;if(h!=u)return!1;if(h&&u)return t.getTime()==i.getTime();var p=t instanceof RegExp,w=i instanceof RegExp;if(p!=w)return!1;if(p&&w)return t.toString()==i.toString();var f=s(t);if((a=f.length)!==s(i).length)return!1;for(r=a;0!=r--;)if(!o.call(i,f[r]))return!1;for(r=a;0!=r--;)if(!e(t[d=f[r]],i[d]))return!1;return!0}return t!=t&&i!=i}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});let n=!1;t.win10Check=fin.System.getHostSpecs().then(e=>{n=e.name.includes("Windows 10")}),t.isWin10=function(){return n}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(11);class s{constructor(e){this._model=e,this._sourceWindow=null,this._active=!1,this._active=!1,this._pendingGetMousePositionResult=!1,this.createDragWindow(),fin.System.addListener("monitor-info-changed",e=>{this.setWindowBounds(e.virtualScreen)})}showWindow(e){this._sourceWindow=e,this._window.show(),this._window.focus(),this._active=!0}hideWindow(){this._active&&s.onDragDrop.emit(this._sourceWindow),this._active=!1,this._window.hide()}async createDragWindow(){const{virtualScreen:e}=await fin.System.getMonitorInfo();await new Promise(t=>{this._window=new fin.desktop.Window({name:"TabbingDragWindow",url:"about:blank",defaultHeight:100,defaultWidth:100,defaultLeft:0,defaultTop:0,saveWindowState:!1,autoShow:!1,opacity:.01,frame:!1,waitForPageLoad:!1,alwaysOnTop:!0,showTaskbarIcon:!1,smallWindow:!0},()=>{this._window.showAt(e.left-100,e.top-100),t()})}),this.setWindowBounds();const t=this._window.getNativeWindow();t.document.body.addEventListener("dragover",e=>(this._pendingGetMousePositionResult||fin.System.getMousePosition().then(e=>{this._pendingGetMousePositionResult=!1,this._active&&s.onDragOver.emit(this._sourceWindow,{x:e.left,y:e.top})},()=>{this._pendingGetMousePositionResult=!1}),e.preventDefault(),e.stopPropagation(),!0)),t.document.body.addEventListener("drop",e=>(this.hideWindow(),e.preventDefault(),e.stopPropagation(),!0)),t.document.body.addEventListener("click",()=>{console.error("Drag Window Clicked!  Have you called endDrag?"),this.hideWindow()})}async setWindowBounds(e){if(e)this._virtualScreen=e;else{const e=await fin.System.getMonitorInfo();this._virtualScreen=e.virtualScreen}this._window.setBounds(this._virtualScreen.left,this._virtualScreen.top,this._virtualScreen.right-this._virtualScreen.left,this._virtualScreen.bottom-this._virtualScreen.top),this._window.hide()}}s.onDragOver=new n.Signal2,s.onDragDrop=new n.Signal1,t.DragWindowManager=s},,function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(14),s=i(1),o=(()=>{let e=window.location.href;return 0===e.indexOf("http://localhost")&&(e=e.replace("/test","/provider")),e.replace("provider.html","tabbing/tabstrip/tabstrip.html")})();class r{constructor(){this._windowPool=new Map,this._watch=new n.MaskWatch(s.config,{tabstrip:!0}),this._watch.onAdd.add(this.onTabstripConfigAdded,this);for(let e=0;e<r.POOL_MAX_SIZE;e++)this.createAndPool(r.DEFAULT_CONFIG)}static convertToTabstripConfig(e){return"default"===e?r.DEFAULT_CONFIG:e}getNextWindow(e){const t=this._windowPool.get(e.url)||[],i=t.shift();return t.length<r.POOL_MIN_SIZE&&setTimeout(()=>{this.createAndPool(e)},1e3),i}generateTabStripOptions(e){return{name:`TABSET-${fin.desktop.getUuid()}`,url:e.url,autoShow:!1,defaultHeight:e.height,minHeight:e.height,maxHeight:e.height,frame:!1,maximizable:!1,resizable:!0,resizeRegion:{sides:{left:!0,top:!1,right:!0,bottom:!1}},saveWindowState:!1,taskbarIconGroup:name,backgroundThrottling:!0,waitForPageLoad:!1,showTaskbarIcon:!1}}onTabstripConfigAdded(e,t){const i=e.config.tabstrip;this.createAndPool(i)}createAndPool(e){this._windowPool.has(e.url)||this._windowPool.set(e.url,[]),this._windowPool.get(e.url).length<r.POOL_MAX_SIZE&&this.createWindow(e).then(t=>{this.hideOffScreen(t),this._windowPool.get(e.url).push(t),t.addListener("closed",()=>{this.createAndPool(e)})})}async hideOffScreen(e){const{virtualScreen:t}=await fin.System.getMonitorInfo(),{width:i,height:n}=await e.getBounds();await e.showAt(t.left-i,t.top-n),await e.hide()}async createWindow(e){const t=await fin.Window.create(this.generateTabStripOptions(e));return await t.disableFrame(),t}}r.DEFAULT_CONFIG={url:o,height:60},r.POOL_MAX_SIZE=3,r.POOL_MIN_SIZE=1,t.DesktopTabstripFactory=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(0),s=i(9),o=i(1),r=i(13),a=i(22),d=i(23),c=i(24),l=i(25);async function h(){const e=await fin.System.getMonitorInfo()||{};let i=await o.tabService.getTabSaveInfo();const n={},a={};void 0===i&&(i=[]);const c=[];i.forEach(e=>{const t=[];let i=!1;if(e.tabs.forEach(n=>{!o.model.getWindow({uuid:n.uuid,name:n.uuid})?e.groupInfo.active.uuid===n.uuid&&e.groupInfo.active.name===n.name&&(i=!0):t.push(n)}),i&&t.length>=1){const i=t[0];e.groupInfo.active=i}t.length>1?c.push({groupInfo:e.groupInfo,tabs:t}):1===t.length&&d.addToWindowObject(t[0],a)}),c.forEach(e=>{e.tabs.forEach(e=>{d.addToWindowObject(e,n)})});const h=await fin.System.getAllWindows(),p=(await r.promiseMap(h,async e=>{try{const{uuid:t}=e,i=await fin.Application.wrap({uuid:t}),s=await i.isRunning(),c=!!e.mainWindow.name,h=!o.model.getWindow({uuid:t,name:e.mainWindow.name}),p=t===fin.Application.me.uuid;if(!c||!s||p||h)return null;const w=await i.getInfo().catch(e=>(console.log("Appinfo Error",e),{}));w.hasOwnProperty("parentUuid")&&(w.parentUuid=o.loader.getAppParent(t)||w.parentUuid);const f=await i.getWindow(),g=await u(f,e.mainWindow,n);d.adjustSizeOfFormerlyTabbedWindows(g,a),e.childWindows=e.childWindows.filter(e=>null!==o.model.getWindow({uuid:t,name:e.name}));const m=await r.promiseMap(e.childWindows,async e=>{const i={uuid:t,name:e.name||t},s=fin.Window.wrapSync(i),o=await u(s,e,n);return d.adjustSizeOfFormerlyTabbedWindows(o,a),o});return l.wasCreatedFromManifest(w,t)?{uuid:t,mainWindow:g,childWindows:m,confirmed:!1,manifestUrl:w.manifestUrl}:l.canRestoreProgrammatically(w)?{uuid:t,mainWindow:g,childWindows:m,confirmed:!1,initialOptions:w.initialOptions,parentUuid:w.parentUuid||void 0}:(console.error("Not saving app, cannot restore:",e),null)}catch(t){return console.error("Error adding app to layout",e,t),null}})).filter(e=>!!e);console.log("Pre-Layout Save Apps:",h),console.log("Post-Layout Valid Apps:",p);const w={type:"workspace",schemaVersion:t.LAYOUTS_SCHEMA_VERSION,apps:p,monitorInfo:e,tabGroups:c},f={type:"workspace-generated",workspace:w};return o.apiHandler.sendToAll(s.EVENT_CHANNEL_TOPIC,f),w}async function u(e,t,i){const{uuid:n,name:s}=e.identity,r={uuid:n,name:s||n},c=await e.getInfo(),l=await a.getGroup(e.identity),h=[];l.forEach(e=>{const t=!!o.model.getWindow({uuid:e.uuid,name:e.uuid}),i=!!o.model.getWindow(e);t&&i&&"layouts-service"!==e.uuid&&h.push(e)});const u=o.model.getWindow(r);if(null===u)throw Error(`No desktop window for window. Name: ${r.name}, UUID: ${r.uuid}`);const p=u.applicationState,w=!!d.inWindowObject(e.identity,i),f=u.currentState.state,g=function(e,...t){const i={};return t.forEach(t=>{i[t]=e[t]}),i}(t,"left","top","width","height"),m=Object.assign({},g,{right:g.left+g.width,bottom:g.top+g.height});return Object.assign({},r,{url:c.url,bounds:m,windowGroup:h,frame:p.frame,state:f,isTabbed:w,isShowing:!p.hidden})}t.LAYOUTS_SCHEMA_VERSION="1.0.0",t.SCHEMA_MAJOR_VERSION=l.parseVersionString(t.LAYOUTS_SCHEMA_VERSION).major,t.getCurrentWorkspace=h,t.generateWorkspace=async function(e,t){const i=await h(),s=await r.promiseMap(i.apps,async e=>{const t=Object.assign({},e);if(o.apiHandler.isClientConnection({uuid:e.uuid,name:e.mainWindow.name})){if(c.appCanRestore(e.uuid)){console.log("Connected application",e.uuid);let i=void 0;return(i=await o.apiHandler.sendToClient({uuid:e.uuid,name:e.uuid},n.WorkspaceAPI.GENERATE_HANDLER,e))||(i=null),t.customData=i,t.confirmed=!0,t}return console.log("Connected application, but did not signal ability to restore",e.uuid),t}return console.log("Unconnected application",e.uuid),t});return Object.assign({},i,{apps:s})}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(1),s=i(13);t.getGroup=e=>{const{uuid:t,name:i}=e,n=fin.desktop.Window.wrap(t,i);return new Promise((e,s)=>{n.getGroup(n=>{const s=n.map(e=>({uuid:e.uuid,name:e.name})).filter(e=>e.uuid!==t||e.name!==i);e(s)},()=>e([]))})},t.regroupWorkspace=async e=>{await s.promiseMap(e,async e=>{await t.groupWindow(e.mainWindow),await s.promiseMap(e.childWindows,async e=>{await t.groupWindow(e)})})},t.groupWindow=async e=>{await s.promiseMap(e.windowGroup,async t=>{if("layouts-service"===t.uuid)return;const i=await n.model.expect(t),s=await n.model.expect(e);if(i&&s){const n=s.tabGroup||s,o=i.tabGroup||i;if(o.snapGroup.id!==n.snapGroup.id)try{await o.setSnapGroup(n.snapGroup)}catch(i){console.error("setSnapGroup in groupWindow failed for: ",e,t)}}})}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(1),s=i(2),o=i(17),r=(()=>{let e=window.location.href;return 0===e.indexOf("http://localhost")&&(e=e.replace("/test","/provider")),e.replace("provider.html","workspaces/placeholder/placeholder.html")})(),a=new Map,d=new Map,c=new Set;let l,h;function u(){l=void 0,h=void 0,a.clear(),d.clear(),c.clear()}async function p(e,i){const n=await t.createTabPlaceholder(e);i[e.uuid]=Object.assign({},i[e.uuid],{[e.name]:{name:n.identity.name,uuid:n.identity.uuid}})}function w(e,t){return!!(e.name&&t[e.uuid]&&t[e.uuid][e.name])}function f(e){return`${e.uuid}/${e.name}`}fin.System.addListener("window-closed",e=>{e.name.startsWith("Placeholder-")&&function(e){const t=d.get(e.name);t&&(c.add(f(t)),m(e));0===a.size&&l&&(clearTimeout(h),l())}(e)}),t.createNormalPlaceholder=async e=>{const{name:i,uuid:s,isShowing:o,state:r}=e;if(!o||"minimized"===r)return;const a=await g(e),d=await fin.Window.wrap({uuid:s,name:i}),c=async()=>{try{await d.removeListener("show-requested",c),await n.model.expect(d.identity),await t.positionWindow(e,!0)}finally{await y(a)}};return await d.addListener("show-requested",c),a},t.createTabPlaceholder=async e=>{const{name:t,uuid:i}=e,s=await g(e),o=await n.model.expect(s.identity),r=await fin.Window.wrap({uuid:i,name:t}),a=async()=>{try{await r.removeListener("shown",a),await n.model.expect(r.identity),await async function(e){return new Promise(t=>setTimeout(t,e))}(500),o.isReady?o.tabGroup?await n.tabService.swapTab(s.identity,r.identity):console.error(`Placeholder window for ${e.uuid} - ${e.name} lost its Tab Group. Other windows tabbed to it may have been closed.`):console.error(`Placeholder window for ${e.uuid} - ${e.name} was closed before the actual window came up. \n                    You may have hanging windows that should have been tabbed.`)}finally{await y(s)}};return await r.addListener("shown",a),s},t.waitUntilAllPlaceholdersClosed=async function(){if(l)throw new Error("waitUntilAllPlaceholdersClosed was called while already waiting for placeholders to close. \n        Restore was called before another restoration had completed. Please close all remaining placeholder windows.");if(0!==a.size)return new Promise((e,t)=>{l=e,h=window.setTimeout(async()=>{t(new Error(`${a.size} Placeholder(s) Left Open after 60 seconds. ${a.size} Window(s) did not come up. Attempting to group anyway.`)),await async function(){for(const e of a.values())await y(e)}(),u()},6e4)})},t.closeCorrespondingPlaceholder=async function(e){const t=function(e){const t={uuid:e.uuid,name:e.name||e.uuid};return a.get(f(t))}(e);t?await y(t):console.warn("No placeholder returned for given identity in closeCorrespondingPlaceholder. \n            Either Placeholder is already closed, or identity given was invalid: ",e)},t.cleanupPlaceholderObjects=u,t.getWindowsWithManuallyClosedPlaceholders=function(){return c},t.positionWindow=async(e,t)=>{try{const{isShowing:i,isTabbed:n}=e,s=await fin.Window.wrap(e);if(await s.setBounds(e.bounds),n)return void(t&&await s.show());if(await s.leaveGroup(),!i)return void await s.hide();"normal"===e.state?(await s.restore(),await s.show()):"minimized"===e.state?await s.minimize():"maximized"===e.state&&await s.maximize()}catch(e){console.error("Position window error: ",e)}},t.createTabbedPlaceholderAndRecord=p,t.childWindowPlaceholderCheck=async function(e,i,n){if(e.confirmed)for(const s of e.childWindows)w(s,i)?await p(s,n):await t.createNormalPlaceholder(s)},t.childWindowPlaceholderCheckRunningApp=async function(e,i,o,r){if(e.confirmed)for(const a of e.childWindows)if(w(a,r)){const e=n.model.getWindow(a);await n.tabService.removeTab(a),e&&e.snapGroup.length>1&&await e.setSnapGroup(new s.DesktopSnapGroup)}else w(a,i)?await p(a,o):await t.createNormalPlaceholder(a)},t.inWindowObject=w,t.addToWindowObject=function(e,t){t[e.uuid]=Object.assign({},t[e.uuid],{[e.name]:!0})},t.adjustSizeOfFormerlyTabbedWindows=function(e,t){if(w(e,t)){const t=n.model.getWindow(e);if(t){const i=t.applicationState,n=t.tabGroup;if(n){const t=n.config.height,s=e.bounds;s.top-=t,s.height+=t,o.isWin10()&&!0===i.frame&&(s.left-=7,s.width+=14,s.height+=7),s.right=s.left+s.width,s.bottom=s.top+s.height}}}},t.getId=f;const g=async e=>{const{height:t,width:i,left:n,top:s}=e.bounds,o="Placeholder-"+Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15),c=await fin.Window.create({url:r,name:o,autoShow:!0,defaultHeight:t,defaultWidth:i,defaultLeft:n,defaultTop:s,saveWindowState:!1,opacity:.6,frame:!1,backgroundColor:"#D3D3D3"});return c&&function(e,t){!function(e,t){a.set(f(e),t),d.set(`${t.identity.name}`,e)}(e,t)}(e,c),c};function m(e){const t=d.get(e.name);t&&(a.delete(f(t)),d.delete(e.name))}async function y(e){const t=await n.model.expect(e.identity);t&&t.isReady&&(await n.tabService.removeTab(e.identity),m(e.identity),await t.close())}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(0),s=i(9),o=i(1),r=i(2),a=i(13),d=i(22),c=i(23),l=i(25),h=new Map,u=new Map,p=new Set;let w=null;t.restoreWorkspace=async e=>{if(console.log("Restoring workspace:",e),null!==w)throw new Error("Attempting to restore while restore in progress");l.linkAppsToOriginalParentUuid(e),l.validatePayload(e),f();const t=e,i=[];await g(t);const n=await a.promiseMap(t.apps,e=>m(e,i)),r=await Promise.all(i),h=l.consolidateAppResponses(n,r),u=await a.promiseFilter(h,async e=>y(e,t));t.apps=u;try{await c.waitUntilAllPlaceholdersClosed()}catch(e){console.warn(e)}await b(t),await d.regroupWorkspace(u).catch(console.log);for(const e of o.model.snapGroups)e.validate();const p={type:"workspace-restored",workspace:t};return o.apiHandler.sendToAll(s.EVENT_CHANNEL_TOPIC,p),_(),console.log("Restore completed: ",t),t},t.appCanRestore=e=>h.has(e),t.appReadyForRestore=async e=>{h.set(e,!0);const t=u.get(e);if(t){const{workspaceApp:i,resolve:n,timeout:s}=t;clearTimeout(s),u.delete(e),A(i,n)}else console.warn("Ignoring duplicate 'appReadyForRestore' call")};const f=()=>{(()=>{const e=w={};setTimeout(()=>{e===w&&_()},12e4)})()},g=async e=>{const t={},i={},n={};e.tabGroups.forEach(e=>{e.tabs.forEach(e=>{c.addToWindowObject(e,t)})}),(await fin.System.getAllWindows()).forEach(e=>{i[e.uuid]=Object.assign({},i[e.uuid],{[e.mainWindow.name]:!0}),e.childWindows.forEach(t=>{i[e.uuid]=Object.assign({},i[e.uuid],{[t.name]:!0})})}),await a.promiseMap(e.apps,async function(e){const s=fin.Application.wrapSync(e);if(await s.isRunning()){const s=o.model.getWindow(e.mainWindow);await o.tabService.removeTab(e.mainWindow),await c.childWindowPlaceholderCheckRunningApp(e,t,n,i),s&&s.snapGroup.length>1&&await s.setSnapGroup(new r.DesktopSnapGroup)}else c.inWindowObject(e.mainWindow,t)?await c.createTabbedPlaceholderAndRecord(e.mainWindow,n):await c.createNormalPlaceholder(e.mainWindow),await c.childWindowPlaceholderCheck(e,t,n)});const s=JSON.parse(JSON.stringify(e.tabGroups));s.forEach(e=>{const t=e.groupInfo.active;c.inWindowObject(t,n)&&(e.groupInfo.active=n[t.uuid][t.name]),e.tabs.forEach((t,i)=>{c.inWindowObject(t,n)&&(e.tabs[i]=n[t.uuid][t.name])})}),await o.tabService.createTabGroupsFromWorkspace(s)},m=async(e,t)=>{const i=Object.assign({},e,{childWindows:[]});try{const{uuid:n}=e;console.log("Restoring App:",e);const s=await fin.Application.wrap({uuid:n});if(await s.isRunning()){return o.apiHandler.channel.connections.some(e=>e.uuid===n&&e.name===n)?(await c.positionWindow(e.mainWindow,!1),console.log("App is running:",e),await T(e)):(console.log("App is open, but not connected to the service:",e),await c.positionWindow(e.mainWindow,!1),i)}{let s;if(console.log("App is not running:",e),e.confirmed&&t.push(new Promise(t=>{S(e,t)})),e.manifestUrl){const{manifestUrl:t}=e;console.log("App has manifestUrl:",e),s=await fin.Application.createFromManifest(t)}else l.canRestoreProgrammatically(e)?(console.warn("App created programmatically, app may not restart again:",e),s=await fin.Application.create(e.initialOptions)):console.error("Unable to restart programmatically launched app:",e);return s&&(await v(s),await o.model.expect({uuid:n,name:n}),await c.positionWindow(e.mainWindow,!0)),i}}catch(t){return console.error("Error restoring app",e,t),E(e),i}},y=async(e,t)=>{if(p.has(e.uuid))return console.error(`App launch for ${e.uuid} failed. Application will be removed from workspace: `,e),await c.closeCorrespondingPlaceholder(e),a.promiseForEach(e.childWindows,c.closeCorrespondingPlaceholder),!1;{const i=t.apps.find(t=>t.uuid===e.uuid);return a.promiseForEach(i.childWindows,async t=>{e.childWindows.some(e=>e.name===t.name)||(console.error(`Application ${e.uuid} did not restore its child window ${t.name} \n                        (or the App's setGenerateHandler didn't return that child window). Placeholder will be closed: \n                    `,e),await c.closeCorrespondingPlaceholder(t))}),!0}},b=async e=>{const t=c.getWindowsWithManuallyClosedPlaceholders();if(0===t.size)return;const i=[];for(const n of e.tabGroups){const e=n.tabs.filter(e=>t.has(c.getId(e)));if(0===e.length)continue;let s=null;for(const e of n.tabs){const i=!t.has(c.getId(e))&&await o.model.expect(e);s=i&&i.tabGroup}if(s){const t=await a.promiseMap(e,async e=>o.model.expect(e));await s.addTabs(t.filter(e=>e.isReady));const i=await o.model.expect(n.groupInfo.active);i&&i.isReady&&await s.switchTab(i)}else i.push(n)}await o.tabService.createTabGroupsFromWorkspace(i)},_=()=>{w=null,c.cleanupPlaceholderObjects(),p.clear(),u.clear()},S=(e,t)=>{const{uuid:i}=e,n=Object.assign({},e,{childWindows:[],confirmed:!1}),s=window.setTimeout(()=>{u.delete(i)&&(console.error(`App ${i} failed to call its ready function. \n                App is either not launching, or didn't call ready. \n                Application's child windows and confirmed status will be removed: `,e),a.promiseForEach(e.childWindows,c.closeCorrespondingPlaceholder),t(n))},6e4),o={workspaceApp:e,resolve:t,timeout:s};u.set(i,o)},T=async e=>{const t={uuid:e.uuid,name:e.uuid},i=Object.assign({},e,{childWindows:[],confirmed:!1});let s;const r=o.apiHandler.sendToClient(t,n.WorkspaceAPI.RESTORE_HANDLER,e).then(e=>(s&&clearTimeout(s),e||i)),d=new Promise(t=>s=window.setTimeout(()=>{console.error(`Sent WorkspaceApp object to ${e.uuid}'s restore handler, but it timed out. \n            Child window restoration may have failed. \n            Application's child windows and confirmed status will be removed: `,e),a.promiseForEach(e.childWindows,c.closeCorrespondingPlaceholder),t(i)},6e4));try{return await Promise.race([r,d])}catch(t){return console.error("Error attempting to send workspace to client app: ",e,t),i}},v=async e=>{let t;const i=new Promise((i,n)=>t=window.setTimeout(()=>{n(new Error(`Run was called on Application ${e.identity.uuid}, but it seems to be hanging. Continuing restoration.`))},6e4)),n=e.run();await Promise.race([i,n]),clearTimeout(t)},E=e=>{p.add(e.uuid);const t=u.get(e.uuid);if(t){u.delete(e.uuid);const{workspaceApp:i,resolve:n,timeout:s}=t;clearTimeout(s),n(i)}},A=async(e,t)=>{const{uuid:i}=e;if(o.apiHandler.isClientConnection({uuid:i,name:i})){t(await T(e))}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(1),s=i(21);function o(e){const t=/([1-9]+)\.([0-9]+)\.([0-9]+)/.exec(e);if(!t)throw new Error('Invalid version string. Must be in semver format ("a.b.c")');return{major:Number.parseInt(t[1],10),minor:Number.parseInt(t[2],10),patch:Number.parseInt(t[3],10)}}t.linkAppsToOriginalParentUuid=e=>{e.apps.forEach(e=>{e.parentUuid&&n.loader.overrideAppParent(e.uuid,e.parentUuid)})},t.validatePayload=e=>{if(!e)throw new Error("Received invalid workspace object");if(!e.schemaVersion)throw new Error("Received invalid workspace object: payload.schemaVersion is undefined");{let t;try{t=o(e.schemaVersion)}catch(e){throw new Error('Received invalid workspace object: schemaVersion string does not comply with semver format ("a.b.c")')}if(t.major>s.SCHEMA_MAJOR_VERSION)throw new Error(`Received incompatible worksapce object. Provided schemaVersion is ${e.schemaVersion}, but this version of the service only supports versions up to ${s.SCHEMA_MAJOR_VERSION}.x.x`)}if(!e.apps)throw new Error("Received invalid workspace object: payload.apps is undefined");if(!e.monitorInfo)throw new Error("Received invalid workspace object: payload.monitorInfo is undefined")},t.consolidateAppResponses=(e,t)=>e.map(e=>{const i=t.find(t=>t.uuid===e.uuid);return i||e}),t.canRestoreProgrammatically=e=>{const t=e.initialOptions;if(e&&t&&t.uuid){if(t.url)return!0;if(t.mainWindowOptions&&t.mainWindowOptions.url)return!0}return!1},t.wasCreatedFromManifest=(e,t)=>{const{manifest:i}=e,n=t||void 0;return"object"==typeof i&&e.manifestUrl&&i.startup_app&&i.startup_app.uuid===n},t.parseVersionString=o},,function(e,t,i){"use strict";var n=this&&this.__rest||function(e,t){var i={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(i[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(n=Object.getOwnPropertySymbols(e);s<n.length;s++)t.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(e,n[s])&&(i[n[s]]=e[n[s]])}return i};Object.defineProperty(t,"__esModule",{value:!0});const s=i(8);t.Store=class{constructor(e){this._items=new Map,this._cache=new Map,this._watches=[],this.add({level:"service"},e)}add(e,t){t.rules&&(t.rules.forEach(t=>{this.addRule(e,t.scope,t.config)}),delete(t=Object.assign({},t)).rules),s.ConfigUtil.containsConfig(t)&&this.addInternal(e,e,t)}addRule(e,t,i){s.ConfigUtil.ruleCanBeAddedInScope(t,e)?this.addInternal(e,t,i):console.warn(`Ignoring ${s.ConfigUtil.getId(t)} rule in config with scope ${s.ConfigUtil.getId(e)}`)}removeFromSource(e){this._items.forEach(t=>{t.slice().forEach(i=>{if(s.ConfigUtil.scopesEqual(i.source,e)){const e=t.indexOf(i);e>=0?(t.splice(e,1),this._cache.clear(),this.checkWatches(i,"onRemove")):console.warn("Config was removed whilst iterating over array, ignoring...")}})}),this._cache.clear()}addWatch(e){const t=this._watches.indexOf(e);if(e.store!==this)throw new Error("Cannot attach a watch listener that was created with a different store");-1===t?this._watches.push(e):console.warn("addWatch: Watch already exists within store, ignoring...",e)}removeWatch(e){const t=this._watches.indexOf(e);t>=0?this._watches.splice(t,1):console.warn("removeWatch: Watch not present within store, ignoring...",e)}query(e){const t={},i=s.ConfigUtil.getId(e);if(this._cache.has(i))return this._cache.get(i);for(let i=0,n=s.ScopePrecedence[e.level];i<=n;i++){const n=(this._items.get(s.ScopePrecedence[i])||[]).filter(t=>s.ConfigUtil.matchesRule(t.scope,e));1===n.length?s.ConfigUtil.deepAssign(t,n[0].config):n.length>1&&this.applyPrecedenceRules(n).forEach(e=>{s.ConfigUtil.deepAssign(t,e.config)})}return this._cache.set(i,t),t}queryPartial(e,t){const i={},n=s.ScopePrecedence[e.level];for(let o=0;o<=n;o++){const n=(this._items.get(s.ScopePrecedence[o])||[]).filter(t=>s.ConfigUtil.matchesRule(t.scope,e));n&&n.forEach(n=>{s.ConfigUtil.matchesRule(n.scope,e)&&s.ConfigUtil.deepAssignMask(i,n.config,t)})}return i}addInternal(e,t,i){this._cache.clear();let n=this._items.get(t.level);n||(n=[],this._items.set(t.level,n));const o={source:e,scope:t,config:i},r=n.find(i=>s.ConfigUtil.scopesEqual(e,i.source)&&s.ConfigUtil.rulesEqual(t,i.scope));r?s.ConfigUtil.deepAssign(r.config,i):n.push(o),this.checkWatches(o,"onAdd")}applyPrecedenceRules(e){return e.sort((t,i)=>t.scope.level!==i.scope.level?s.ScopePrecedence[t.scope.level]-s.ScopePrecedence[i.scope.level]:t.source.level!==i.source.level?s.ScopePrecedence[t.source.level]-s.ScopePrecedence[i.source.level]:this.getSpecifity(t.scope)!==this.getSpecifity(i.scope)?this.getSpecifity(t.scope)-this.getSpecifity(i.scope):e.indexOf(t)-e.indexOf(i))}getSpecifity(e){switch(e.level){case"application":return"string"==typeof e.uuid?1:0;case"window":return("string"==typeof e.uuid?1:0)+("string"==typeof e.name?1:0);default:return 0}}checkWatches(e,t){const{source:i}=e,s=n(e,["source"]);this._watches.forEach(n=>{n[t].slots.length>0&&n.matches(e)&&n[t].emit(s,i)})}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(8),s=i(14);t.Loader=class{constructor(e,t,i){this._store=e,this._serviceNames=Array.isArray(t)?t.slice():[t],this._defaultConfig=i||null,this._appState={},this._appParentMap={},this._windowsWithConfig=[],this._watch=new s.SourceWatch(this._store,{level:"window",uuid:{expression:".*"},name:{expression:".*"}}),this._watch.onAdd.add(this.onConfigAddedFromWindow,this),this.onApplicationCreated=this.onApplicationCreated.bind(this),this.onApplicationClosed=this.onApplicationClosed.bind(this),this.onWindowClosed=this.onWindowClosed.bind(this),fin.System.addListener("application-created",this.onApplicationCreated),fin.System.getAllApplications().then(e=>{e.forEach(e=>{e.isRunning&&this.onApplicationCreated(e)})})}overrideAppParent(e,t){void 0!==this._appParentMap[e]&&console.warn("Application already existed within expectedAppState map:",e),this._appParentMap[e]=t}getAppParent(e){const t=this.getAppState(e);return t&&t.parent&&t.parent.scope.uuid||void 0}onApplicationCreated(e){const t=fin.Application.wrapSync(e);e.uuid!==fin.Application.me.uuid&&t.getInfo().then(i=>{const n=i.manifest,s=!!n&&n.startup_app.uuid===e.uuid;let o=i.parentUuid,r=null,a=!1;const d=this._appParentMap[e.uuid];if(d&&(console.log(`Tracking ${e.uuid} as having parent ${d} over ${o}`),o=d,delete this._appParentMap[e.uuid]),s&&n.services&&n.services.length)n.services.forEach(t=>{this._serviceNames.includes(t.name)&&(a=!0,t.config?(console.log(`Using config from ${e.uuid}/${t.name}`),r=t.config):console.log(`App ${e.uuid}/${t.name} declares service, but doesn't contain config`))});else if(!s&&o&&this._appState.hasOwnProperty(o)){const e=this.getAppState(o);a=e.isServiceAware}if(o&&(this._appState.hasOwnProperty(o)||!s)){let i=this.getAppState(o);i||(console.log(`Late-registering ${o} as service-aware (manifest-launched) app`),i=this.getOrCreateAppState(fin.Application.wrapSync({uuid:o}),!0));const n=this.getOrCreateAppState(t,i.isServiceAware);console.log(`Registering ${e.uuid} as a child of ${i.scope.uuid}`),n.parent=i,i.children.push(n)}if(!a&&this._defaultConfig){const t=this.getAppState(o||"");t&&t.isServiceAware?console.log(`Not applying default state to ${e.uuid}, due to service-aware parent app`):(console.log(`Using default config for ${e.uuid}`),r=this._defaultConfig)}if(r){const e=this.getOrCreateAppState(t,a);this._store.add(e.scope,r)}})}onApplicationClosed(e){const t=e.uuid,i=this._appState[t];if(fin.Application.wrapSync({uuid:e.uuid}).removeListener("closed",this.onApplicationClosed),i){i.isRunning=!1,this.cleanUpApplicationConfig(i);let e=i;for(;e.parent&&!e.parent.isRunning;)e=e.parent,console.log("Checking parent",e.scope.uuid),this.cleanUpApplicationConfig(e)}}cleanUpApplicationConfig(e){if(e.children.forEach(e=>this.cleanUpApplicationConfig(e)),!e.isRunning&&0===e.children.length){console.log(`Discarding config from ${e.scope.uuid}`),this._store.removeFromSource(e.scope);const t=e.parent?e.parent.children.indexOf(e):-1;t>=0&&e.parent.children.splice(t,1),delete this._appState[e.scope.uuid]}}onWindowClosed(e){const t={level:"window",uuid:e.uuid,name:e.name};console.log(`Unloading config from Window '${t.uuid}/${t.name}'`),this._store.removeFromSource(t);const i=n.ConfigUtil.getId(t),s=this._windowsWithConfig.indexOf(i);s>=0&&this._windowsWithConfig.splice(s,1)}onConfigAddedFromWindow(e,t){const i=n.ConfigUtil.getId(t);"window"!==t.level||this._windowsWithConfig.includes(i)||(this._windowsWithConfig.push(i),fin.Window.wrapSync(t).once("closed",this.onWindowClosed))}getAppState(e){const t=e.uuid||e;return this._appState[t]||null}getOrCreateAppState(e,t){const i=e.identity.uuid;let n=this._appState[i];return n||(n={scope:{level:"application",uuid:i},isRunning:!0,parent:null,children:[],isServiceAware:t},e.addListener("closed",this.onApplicationClosed),this._appState[i]=n),n}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.Aggregators=class{static ARRAY(e){return e}static AWAIT(e){return Promise.all(e)}static async AWAIT_VOID(e){await Promise.all(e)}};class n{constructor(e,t){this._length=e,this._slots=[],this.aggregator=t||null}get length(){return this._length}get slots(){return this._slots}addInternal(e,t){if(e.length===this._length){const i={callback:e,context:t,remove:()=>this.removeSlot(i)};return this._slots.push(i),i}throw new Error("Callback function must accept "+this._length+" arguments")}removeInternal(e,t){const i=this._slots.findIndex(i=>i.callback===e&&i.context===t);return i>=0&&(this._slots.splice(i,1),!0)}hasInternal(e,t){return this._slots.findIndex(i=>i.callback===e&&i.context===t)>=0}emitInternal(...e){const t=this._slots.slice();return this.aggregator?this.aggregator(t.map(t=>t.callback.apply(t.context,e))):void t.forEach(t=>t.callback.apply(t.context,e))}removeSlot(e){const t=this._slots.indexOf(e);t>=0&&this._slots.splice(t,1)}}t.Signal0=class extends n{constructor(e){super(0,e)}add(e,t){return super.addInternal(e,t)}remove(e,t){return super.removeInternal(e,t)}has(e,t){return super.hasInternal(e,t)}emit(){return super.emitInternal()}};t.Signal1=class extends n{constructor(e){super(1,e)}add(e,t){return super.addInternal(e,t)}remove(e,t){return super.removeInternal(e,t)}has(e,t){return super.hasInternal(e,t)}emit(e){return super.emitInternal(e)}};t.Signal2=class extends n{constructor(e){super(2,e)}add(e,t){return super.addInternal(e,t)}remove(e,t){return super.removeInternal(e,t)}has(e,t){return super.hasInternal(e,t)}emit(e,t){return super.emitInternal(e,t)}};t.Signal3=class extends n{constructor(e){super(3,e)}add(e,t){return super.addInternal(e,t)}remove(e,t){return super.removeInternal(e,t)}has(e,t){return super.hasInternal(e,t)}emit(e,t,i){return super.emitInternal(e,t,i)}};t.Signal4=class extends n{constructor(e){super(4,e)}add(e,t){return super.addInternal(e,t)}remove(e,t){return super.removeInternal(e,t)}has(e,t){return super.hasInternal(e,t)}emit(e,t,i,n){return super.emitInternal(e,t,i,n)}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(0),s=i(9),o=i(10),r=i(21),a=i(24);t.APIHandler=class{constructor(e,t,i,n){this._model=e,this._config=t,this._snapService=i,this._tabService=n}get channel(){return this._providerChannel}isClientConnection(e){return this._providerChannel.connections.some(t=>e.uuid===t.uuid&&e.name===t.name)}async sendToClient(e,t,i){return this._providerChannel.dispatch(e,t,i)}async sendToAll(e,t){await this._providerChannel.publish(e,t)}async registerListeners(){(this._providerChannel=await fin.InterApplicationBus.Channel.create(n.SERVICE_CHANNEL)).onConnection(this.onConnection),this.registerListener(n.RegisterAPI.REGISTER,this.register),this.registerListener(n.RegisterAPI.DEREGISTER,this.deregister),this.registerListener(n.SnapAndDockAPI.UNDOCK_WINDOW,this.undockWindow),this.registerListener(n.SnapAndDockAPI.UNDOCK_GROUP,this.undockGroup),this.registerListener(n.SnapAndDockAPI.GET_DOCKED_WINDOWS,this.getDockedWindows),this.registerListener(n.WorkspaceAPI.GENERATE_LAYOUT,r.generateWorkspace),this.registerListener(n.WorkspaceAPI.RESTORE_LAYOUT,a.restoreWorkspace),this.registerListener(n.WorkspaceAPI.APPLICATION_READY,this.appReady),this.registerListener(n.TabAPI.CLOSETABGROUP,this.closeTabGroup),this.registerListener(n.TabAPI.CREATETABGROUP,this.createTabGroup),this.registerListener(n.TabAPI.STARTDRAG,this.startDrag),this.registerListener(n.TabAPI.ENDDRAG,this.endDrag),this.registerListener(n.TabAPI.GETTABS,this.getTabs),this.registerListener(n.TabAPI.MAXIMIZETABGROUP,this.maximizeTabGroup),this.registerListener(n.TabAPI.MINIMIZETABGROUP,this.minimizeTabGroup),this.registerListener(n.TabAPI.REMOVETAB,this.removeTab),this.registerListener(n.TabAPI.CLOSETAB,this.closeTab),this.registerListener(n.TabAPI.REORDERTABS,this.reorderTabs),this.registerListener(n.TabAPI.RESTORETABGROUP,this.restoreTabGroup),this.registerListener(n.TabAPI.SETACTIVETAB,this.setActiveTab),this.registerListener(n.TabAPI.SETTABSTRIP,this.setTabstrip),this.registerListener(n.TabAPI.UPDATETABPROPERTIES,this.updateTabProperties),this.registerListener(n.TabAPI.TAB_WINDOW_TO_WINDOW,this.addTab)}registerListener(e,t){t=t.bind(this),this._providerChannel.register(e,t)}onConnection(e,t){t&&t.version&&t.version.length>0?console.log(`connection from client: ${e.name}, version: ${t.version}`):console.log(`connection from client: ${e.name}, unable to determine version`)}async register(e,t){try{this._model.register(e,{level:"window",uuid:t.uuid,name:t.name||t.uuid})}catch(e){throw console.error(e),new Error(s.getErrorMessage(s.ErrorType.UNEXPECTED,{action:"registering",error:e}))}}async deregister(e,t){try{this._model.deregister(e,{level:"window",uuid:t.uuid,name:t.name||t.uuid})}catch(e){throw console.error(e),new Error(s.getErrorMessage(s.ErrorType.UNEXPECTED,{action:"deregistering",error:e}))}}async undockWindow(e){return this._snapService.undock(e)}async undockGroup(e){return this._snapService.explodeGroup(e)}async getDockedWindows(e){const t=this._model.getWindow(e);if(!t)throw new Error(s.getErrorMessage(s.ErrorType.NO_WINDOW,e));return 1===t.snapGroup.entities.length?null:t.snapGroup.entities.map(e=>e instanceof o.DesktopTabGroup?e.tabs.map(e=>e.identity):e.identity)}appReady(e,t){a.appReadyForRestore(t.uuid)}setTabstrip(e){this._config.add({level:"application",uuid:e.id.uuid},{tabstrip:e.config})}getTabs(e){const t=this._model.getWindow(e),i=t&&t.tabGroup;return i?i.tabs.map(e=>e.identity):null}async createTabGroup(e){return this._tabService.createTabGroupWithTabs(e.windows,e.activeTab)}async addTab(e){const t=this._model.getWindow(e.windowToAdd),i=this._model.getWindow(e.targetWindow);if(!t)throw new Error(s.getErrorMessage(s.ErrorType.NO_WINDOW,e.windowToAdd));if(!i)throw new Error(s.getErrorMessage(s.ErrorType.NO_WINDOW,e.targetWindow));if(t===i)throw new Error("You cannot tab a window to itself.");if(this._tabService.canTabTogether(i,t)){const n=i.tabGroup;return n?n.addTab(t):this._tabService.createTabGroupWithTabs([e.targetWindow,e.windowToAdd],e.windowToAdd)}throw console.error("The tabs provided have incompatible tabstrip URLs"),new Error("The tabs provided have incompatible tabstrip URLs")}async removeTab(e){const t=this._model.getWindow(e),i=t&&t.tabGroup;if(i)return i.removeTab(t);if(!t)throw new Error(s.getErrorMessage(s.ErrorType.NO_WINDOW,e))}setActiveTab(e){const t=this._model.getWindow(e),i=t&&t.tabGroup;if(!t)throw new Error(s.getErrorMessage(s.ErrorType.NO_WINDOW,e));if(!i)throw new Error(s.getErrorMessage(s.ErrorType.NO_TAB_GROUP,e));return i.switchTab(t)}async closeTab(e){const t=this._model.getWindow(e);if(!t)throw new Error(s.getErrorMessage(s.ErrorType.NO_WINDOW,e));return t.close()}async minimizeTabGroup(e){const t=this._model.getWindow(e),i=t&&t.tabGroup;if(!t)throw new Error(s.getErrorMessage(s.ErrorType.NO_WINDOW,e));if(!i)throw new Error(s.getErrorMessage(s.ErrorType.NO_TAB_GROUP,e));return i.minimize()}async maximizeTabGroup(e){const t=this._model.getWindow(e),i=t&&t.tabGroup;if(!t)throw new Error(s.getErrorMessage(s.ErrorType.NO_WINDOW,e));if(!i)throw new Error(s.getErrorMessage(s.ErrorType.NO_TAB_GROUP,e));return i.maximize()}async closeTabGroup(e){const t=this._model.getWindow(e),i=t&&t.tabGroup;if(!t)throw new Error(s.getErrorMessage(s.ErrorType.NO_WINDOW,e));if(!i)throw new Error(s.getErrorMessage(s.ErrorType.NO_TAB_GROUP,e));return i.removeAllTabs(!0)}async restoreTabGroup(e){const t=this._model.getWindow(e),i=t&&t.tabGroup;if(!t)throw new Error(s.getErrorMessage(s.ErrorType.NO_WINDOW,e));if(!i)throw new Error(s.getErrorMessage(s.ErrorType.NO_TAB_GROUP,e));return i.restore()}reorderTabs(e,t){if(!Array.isArray(e)||0===e.length)throw new Error("Invalid new Order array");const i=this._model.getWindow(t),n=i&&i.tabGroup;if(!n)throw new Error(s.getErrorMessage(s.ErrorType.NO_TAB_GROUP,t));return n.reorderTabArray(e)}updateTabProperties(e){const t=this._model.getWindow(e.window);if(!t)throw new Error(s.getErrorMessage(s.ErrorType.NO_WINDOW,e.window));return this._tabService.updateTabProperties(t,e.properties)}startDrag(e,t){const i=this._model.getWindow(e),n=i&&i.tabGroup;if(!i)throw new Error(s.getErrorMessage(s.ErrorType.NO_WINDOW,e));if(!n)throw new Error(s.getErrorMessage(s.ErrorType.NO_TAB_GROUP,e));this._tabService.dragWindowManager.showWindow(i)}async endDrag(){this._tabService.dragWindowManager.hideWindow()}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CalculatedProperty=class{constructor(e,t){this.lastValue=t,this.requiresRefresh=arguments.length<2,this.refreshFunc=e}get value(){if(this.requiresRefresh){const e=this.refreshFunc();void 0!==e?this.lastValue=e:console.error("CalculatedProperty is stale, but it's refresh function didn't provide an updated value",this)}return this.lastValue}markStale(){this.requiresRefresh=!0}updateValue(e){this.lastValue=e,this.requiresRefresh=!1}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.forEachProperty=function(e,t){Object.keys(e).forEach(e=>t(e))}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(14),s=i(8),o=i(2),r=i(3),a=i(10),d=i(5),c=i(34),l=i(35),h={enabled:!0};t.DesktopModel=class{constructor(e){this._windows=[],this._tabGroups=[],this._snapGroups=[],this._windowLookup={},this._zIndexer=new l.ZIndexer(this),this._mouseTracker=new c.MouseTracker,this._monitors=[],this._displayScaling=!1,d.DesktopWindow.onCreated.add(this.onWindowCreated,this),d.DesktopWindow.onDestroyed.add(this.onWindowDestroyed,this),a.DesktopTabGroup.onCreated.add(this.onTabGroupCreated,this),a.DesktopTabGroup.onDestroyed.add(this.onTabGroupDestroyed,this),o.DesktopSnapGroup.onCreated.add(this.onSnapGroupCreated,this),o.DesktopSnapGroup.onDestroyed.add(this.onSnapGroupDestroyed,this);const t=fin.Application.me.uuid;e.addRule({level:"service"},{level:"application",uuid:t},{enabled:!1}),e.addRule({level:"service"},{level:"window",uuid:t,name:{expression:"Placeholder-.*"}},{enabled:!0,features:{snap:!1,dock:!1}}),e.addRule({level:"service"},{level:"application",uuid:{expression:"error-app-[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}",flags:"g"}},{enabled:!1}),this._config=e,this._watch=new n.MaskWatch(e,{enabled:!0}),this._watch.onAdd.add(this.onRuleAdded,this),this._watch.onRemove.add(this.onRuleRemoved,this),fin.System.addListener("window-created",e=>{this.addIfEnabled({uuid:e.uuid,name:e.name})}),fin.System.getAllWindows().then(e=>{e.forEach(e=>{this.addIfEnabled({uuid:e.uuid,name:e.mainWindow.name}),e.childWindows.forEach(t=>{this.addIfEnabled({uuid:e.uuid,name:t.name})})})}),fin.System.addListener("monitor-info-changed",async e=>{this._monitors=[e.primaryMonitor,...e.nonPrimaryMonitors].map(e=>r.RectUtils.convertToCenterHalfSize(e.monitorRect)),this._displayScaling=1!==e.deviceScaleFactor,this.tabGroups.map(e=>e.validate()),this.snapGroups.map(e=>e.validate())}),fin.System.getMonitorInfo().then(e=>{this._monitors=[e.primaryMonitor,...e.nonPrimaryMonitors].map(e=>r.RectUtils.convertToCenterHalfSize(e.availableRect)),this._displayScaling=1!==e.deviceScaleFactor})}get mouseTracker(){return this._mouseTracker}get windows(){return this._windows}get tabGroups(){return this._tabGroups}get snapGroups(){return this._snapGroups}getId(e){return`${e.uuid}/${e.name}`}get monitors(){return this._monitors}get displayScaling(){return this._displayScaling}getWindow(e){const t="string"==typeof e?e:this.getId(e);return this._windows.find(e=>e.id===t)||null}getWindowAt(e,t,i){const n={x:e,y:t},s=i&&this.getId(i),o=this._windows.filter(e=>{const t=e.currentState;return r.RectUtils.isPointInRect(t.center,t.halfSize,n)}),a=[],d=[];for(const e of o)e.isActive&&e.id!==s?a.push(e):d.push(e.identity);const c=this._zIndexer.getTopMost(a),l=this._zIndexer.getWindowAt(e,t,d);return c&&l&&c.id!==this.getId(l)?null:c}getTabGroup(e){return this._tabGroups.find(t=>t.id===e)||null}getMonitorByRect(e){const t=this._monitors.find(t=>r.RectUtils.isPointInRect(t.center,t.halfSize,e.center));if(t)return r.RectUtils.clone(t);const i=this._monitors.reduce((t,i)=>r.RectUtils.overlappingArea(t,e)>r.RectUtils.overlappingArea(i,e)?t:i);return r.RectUtils.clone(i)}register(e,t){const i=Object.assign({},e,{level:"window"});console.log("Registering",e,"from",t),this._config.addRule(t,i,{enabled:!0})}deregister(e,t){const i=Object.assign({},e,{level:"window"});console.log("Deregistering",e,"from",t),this._config.addRule(t,i,{enabled:!1})}expect(e,t=1e3){let i=null;const n=new Promise((t,n)=>{const s=this.getWindow(e),o=this.getId(e);s?t(s):i=d.DesktopWindow.onCreated.add(e=>{e.id===o&&(i.remove(),t(e))})});let s;const o=e=>(i&&i.remove(),e);return(s=t>0?Promise.race([n,new Promise((e,i)=>setTimeout(i,t))]):n).then(o,o)}async addIfEnabled(e){this._config.queryPartial({level:"window",uuid:e.uuid,name:e.name},h).enabled&&await this.addWindow(e)}addWindow(e){const t=this.getWindow(e);t&&t.teardown();const i=fin.Window.wrapSync(e);return d.DesktopWindow.getWindowState(i).then(t=>this._config.queryPartial(Object.assign({level:"window"},e),h).enabled?(console.log("Registered window: "+this.getId(e)),new d.DesktopWindow(this,i,t)):(console.log("Ignoring window as it was de-registered whilst querying it's state",e),null))}removeWindow(e){try{e.teardown()}catch(e){throw console.error(`Unexpected error when deregistering: ${e}`),new Error(`Unexpected error when deregistering: ${e}`)}}onRuleAdded(e,t){const i=e.config.enabled;this.handleRuleChange(e.scope,i)}onRuleRemoved(e,t){const i=e.config.enabled;this.handleRuleChange(e.scope,!i)}async handleRuleChange(e,t){if(t){const t=(await fin.System.getAllWindows()).reduce((e,t)=>(e.push({level:"window",uuid:t.uuid,name:t.mainWindow.name}),t.childWindows.forEach(i=>{e.push({level:"window",uuid:t.uuid,name:i.name})}),e),[]).filter(t=>s.ConfigUtil.matchesRule(e,t)&&this._config.queryPartial(t,h).enabled&&!this._windows.some(e=>e.identity.uuid===t.uuid&&e.identity.name===t.name));await Promise.all(t.map(e=>this.addWindow(e)))}else{const t=this._windows.filter(t=>{const i=t.scope;return s.ConfigUtil.matchesRule(e,i)&&!this._config.queryPartial(i,h).enabled});await Promise.all(t.map(async(e,t)=>{this.removeWindow(e)}))}}onWindowCreated(e){const t=e.id;this._windowLookup[t]&&(console.warn("Adding a new window with an existing ID",e),this.onWindowDestroyed(this._windowLookup[t])),this._windows.push(e),this._windowLookup[t]=e}onWindowDestroyed(e){const t=e.id,i=this._windows.indexOf(e);i>=0?(this._windows.splice(i,1),delete this._windowLookup[t]):this._windowLookup[t]&&(console.warn("A window existed within lookup, but now window list",e),delete this._windowLookup[t])}onTabGroupCreated(e){this._tabGroups.push(e)}onTabGroupDestroyed(e){const t=this._tabGroups.indexOf(e);t>=0&&(0!==e.tabs.length&&console.warn("Removing a non-empty tab group, this should never happen",e),this._tabGroups.splice(t,1))}onSnapGroupCreated(e){this._snapGroups.push(e)}onSnapGroupDestroyed(e){const t=this._snapGroups.indexOf(e);t>=0&&(0!==e.length&&console.warn("Removing a non-empty snap group, this should never happen",e),this._snapGroups.splice(t,1))}isErrorWindow(e){return/error-app-[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}/g.test(e)}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(18),s=i(5);t.MouseTracker=class{constructor(){this._window=null,this._mouseOffset=null,this._knownPosition=null,s.DesktopWindow.onCreated.add(this.onDesktopWindowCreated,this),s.DesktopWindow.onDestroyed.add(this.onDesktopWindowDestroyed,this),n.DragWindowManager.onDragOver.add(this.onTabDrag,this),n.DragWindowManager.onDragDrop.add(this.onTabDrop,this)}onDesktopWindowCreated(e){e.onTransform.add(this.start,this)}onDesktopWindowDestroyed(e){e.onTransform.remove(this.start,this),e.onCommit.remove(this.end,this)}onTabDrag(e,t){this._knownPosition=t}onTabDrop(e){setTimeout(()=>{this._knownPosition=null},500)}async start(e,t){if(this._window===e)return;this._window&&this.end(e,t),this._window=e,e.onCommit.has(this.end,this)||e.onCommit.add(this.end,this);const i=await fin.System.getMousePosition();if(this._window===e){const t=e.currentState;this._mouseOffset={x:i.left-(t.center.x-t.halfSize.x),y:i.top-(t.center.y-t.halfSize.y)}}}end(e,t){this._window&&(this._window.onCommit.remove(this.end,this),this._window=this._mouseOffset=null)}get isDraggingTab(){return!!this._knownPosition}getPosition(){if(this._window&&this._mouseOffset){const e=this._window.currentState;return{x:this._mouseOffset.x+(e.center.x-e.halfSize.x),y:this._mouseOffset.y+(e.center.y-e.halfSize.y)}}return this._knownPosition?this._knownPosition:null}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(0);t.ZIndexer=class{constructor(e){this._stack=[],this._eventNum=0,this._model=e,fin.System.addListener("window-created",e=>{const t=fin.Window.wrapSync(e);this._addEventListeners(t)}),fin.System.getAllApplications().then(e=>{e.forEach(e=>{const t=fin.Application.wrapSync(e);t.getWindow().then(e=>{this._addEventListeners(e)}),t.getChildWindows().then(e=>{e.forEach(e=>{this._addEventListeners(e)})})})})}getTopMost(e){const t=this.getIds(e);for(const i of this._stack)if(i.active){const n=t.indexOf(i.id);if(n>=0){if(!this.isServiceWindow(i))return e[n];console.warn("Top-most window is a service window, ignoring")}}return null}getWindowAt(e,t,i){const n=this._stack.find(n=>{const s=n.identity;if(n.active){if(this.isServiceWindow(n))return!1;if(i.some(e=>e.uuid===s.uuid&&e.name===s.name))return!1;{const i=n.bounds;return e>=i.left&&e<=i.right&&t>=i.top&&t<=i.bottom}}return!1});return n?n.identity:null}update(e,t,i,n){const s=this._model.getId(e),o=this._stack.find(e=>e.id===s);o?(t<o.eventNum&&console.warn("Out of order update in ZIndexer"),o.eventNum=t,void 0!==i&&(o.active=i),n&&Object.assign(o.bounds,n)):n?this.addToStack({id:s,identity:e,eventNum:t,bounds:n,active:void 0===i||i}):fin.Window.wrapSync(e).getBounds().then(n=>{this.update(e,t,i,this.sanitizeBounds(n))}),this.sortStack()}onWindowModified(e,t,i){const n=this._model.getWindow(e),s=n&&n.snapGroup;if(s&&s.length>1){const n=this._model.getId(e);s.windows.forEach(e=>{const s=e.id===n?i:void 0,o=e.id===n?t:void 0;this.update(e.identity,this.getNextEventNum(),o,s)})}else this.update(e,this.getNextEventNum(),t,i)}async _addEventListeners(e){const t=e.identity,i=()=>{this.onWindowModified(t,!0)},n=e=>{this.onWindowModified(t,void 0,this.sanitizeBounds(e))},s=()=>{e.removeListener("focused",i),e.removeListener("shown",i),e.removeListener("bounds-changed",n),e.removeListener("closed",s);const o=`${t.uuid}/${t.name}`,r=this._stack.findIndex(e=>e.id===o);r>=0&&this._stack.splice(r,1)};e.addListener("focused",i),e.addListener("shown",i),e.addListener("bounds-changed",n),e.addListener("closed",s),await e.isShowing()&&this.update(t,this.getNextEventNum())}addToStack(e){this._stack.push(e)}sortStack(){this._stack.sort((e,t)=>e.active&&!t.active?-1:!e.active&&t.active?1:t.eventNum-e.eventNum)}sanitizeBounds(e){return{left:e.left,top:e.top,right:e.right||e.left+e.width,bottom:e.bottom||e.top+e.height}}getIds(e){return e.map(e=>this.hasIdentity(e)?this._model.getId(e.identity):this._model.getId(e))}hasIdentity(e){return void 0!==e.identity}isServiceWindow(e){const t=e.identity;return t.uuid===n.SERVICE_IDENTITY.uuid&&!t.name.startsWith("TABSET-")}getNextEventNum(){return this._eventNum++}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(2),s=i(12),o=i(37),r=i(4),a=i(3);t.SnapService=class{constructor(e,t){this._model=e,this._config=t,this._resolver=new o.Resolver(t),fin.GlobalHotkey.register("CommandOrControl+Shift+U",()=>{fin.desktop.System.getFocusedWindow(t=>{null!==t&&e.getWindow(t)&&(console.log("Global hotkey invoked on window",t),this.undock(t))})}).catch(console.error)}async undock(e){const t=this._model.getWindow(e);if(t&&t.snapGroup.isNonTrivial()){const e=t.tabGroup||t;try{const t=this.calculateUndockMoveDirection(e);t.x||t.y?(t.x=Math.sign(t.x)*s.UNDOCK_MOVE_DISTANCE,t.y=Math.sign(t.y)*s.UNDOCK_MOVE_DISTANCE):t.x=t.y=s.UNDOCK_MOVE_DISTANCE;const i=new n.DesktopSnapGroup;await e.setSnapGroup(i),await e.applyOffset(t,e.currentState.halfSize)}catch(e){throw console.error(`Unexpected error when undocking window: ${e}`),new Error(`Unexpected error when undocking window: ${e}`)}}else if(!t)throw console.error(`Unable to undock - no window found with identity "${e.uuid}/${e.name}"`),new Error(`Unable to undock - no window found with identity "${e.uuid}/${e.name}"`)}async explodeGroup(e){const t=this._model.getWindow(e),i=t&&t.snapGroup;if(!i)throw console.error(`Unable to undock - no group found for window with identity "${e.uuid}/${e.name}"`),new Error(`Unable to undock - no group found for window with identity "${e.uuid}/${e.name}"`);try{const e=i.entities;if(e.length>1){const t=i.center;await Promise.all(e.slice(1).map(e=>e.setSnapGroup(new n.DesktopSnapGroup))),await Promise.all(e.map(e=>{const i=r.PointUtils.scale(r.PointUtils.difference(t,e.currentState.center),s.EXPLODE_MOVE_SCALE);return e.applyOffset(i,e.currentState.halfSize)}))}}catch(e){throw console.error(`Unexpected error when undocking group: ${e}`),new Error(`Unexpected error when undocking group: ${e}`)}}getTarget(e){return this._resolver.getSnapTarget(this._model.snapGroups,e)}async applySnapTarget(e){if(e.valid){const t=e.activeWindow.snapGroup;if(t.isNonTrivial())throw new Error("Cannot snap two groups together");await e.activeWindow.applyOffset(e.offset,e.halfSize);const i=this._config.query(e.activeWindow.scope).features.dock,n=e.targetGroup.windows.every(e=>this._config.query(e.scope).features.dock);i&&n&&(await e.activeWindow.setSnapGroup(e.targetGroup),this._model.snapGroups.indexOf(t)>=0&&console.warn(`Expected group to have been removed, but still exists (${t.id}: ${t.windows.map(e=>e.id).join()})`))}e.targetGroup.validate()}calculateUndockMoveDirection(e){const t=e.snapGroup,i={x:0,y:0};for(const n of t.entities)if(n!==e){const t=a.RectUtils.distance(e.currentState,n.currentState);0===t.minAbs&&t.min<0&&(i.x=i.x+Math.sign((e.currentState.center.x-n.currentState.center.x)*Math.abs(t.y)),i.y=i.y+Math.sign((e.currentState.center.y-n.currentState.center.y)*Math.abs(t.x)))}return i}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(12),s=i(38),o=i(4),r=i(3);t.Resolver=class{constructor(e){this._projector=new s.Projector,this._config=e}getSnapTarget(e,t){const i=this._projector,s=[];return t.isNonTrivial()?null:(e.forEach(e=>{if(e!==t&&r.RectUtils.distance(t,e).within(n.SNAP_DISTANCE)){i.reset(),t.entities.forEach(t=>{const s=t.currentState;this.isSnappable(t,s)&&r.RectUtils.distance(e,s).within(n.SNAP_DISTANCE)&&e.entities.forEach(e=>{const t=e.currentState;this.isSnappable(e,t)&&i.project(s,t)})});const o=i.createTarget(e,t.entities[0]);o&&s.push(o)}}),0===s.length?null:1===s.length?s[0]:this.findBestTarget(s))}findBestTarget(e){return(e=e.sort((e,t)=>{const i=e.offset;return t.offset,e.valid!==t.valid?e.valid?1:-1:this.isAnchorSnap(e)!==this.isAnchorSnap(t)?i.x&&i.y?-1:1:o.PointUtils.lengthSquared(e.offset)-o.PointUtils.lengthSquared(t.offset)}))[0]||null}isAnchorSnap(e){return 0!==e.offset.x&&0!==e.offset.y}isSnappable(e,t){if(!t.hidden&&"normal"===t.state&&this._config.query(e.scope).features.snap){if(t.opacity>0)return!0;{const t=e.tabGroup&&e.tabGroup.activeTab||e;return t&&t.applicationState.opacity>0}}return!1}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(6),s=i(12),o=i(4),r=i(42),a=i(3);var d;!function(e){e[e.LEFT=0]="LEFT",e[e.TOP=1]="TOP",e[e.RIGHT=2]="RIGHT",e[e.BOTTOM=3]="BOTTOM"}(d=t.eDirection||(t.eDirection={}));t.Projector=class{constructor(){this._blocked=!1,this._borders=[new c(d.LEFT),new c(d.TOP),new c(d.RIGHT),new c(d.BOTTOM)],this.reset()}reset(){this._blocked=!1,this._borders.forEach(e=>{e.limit=e.direction<2?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER,e.distance=Number.MAX_SAFE_INTEGER,e.min=Number.MAX_SAFE_INTEGER,e.max=Number.MIN_SAFE_INTEGER})}project(e,t){const i=a.RectUtils.distance(e,t),n=this.getDirectionFromOffset(i,e,t),s=this._borders[n].project(e,t,i);this._blocked=this._blocked||!s}createTarget(e,t){const i=this._borders;if(!this._blocked){const r=t.currentState,a={x:0,y:0},d=o.PointUtils.clone(r.halfSize),c=i.filter(e=>e.distance<Number.MAX_SAFE_INTEGER&&e.getOverlap(r)>=s.MIN_OVERLAP&&e.distance<=s.SNAP_DISTANCE);if(c.length>0)return this.clipProjections(),c.forEach(e=>{const t=i[(e.direction+2)%4];if(t.distance>s.SNAP_DISTANCE){if(a[e.orientation]=e.distance*Math.sign(.5-Math.floor(e.direction/2)),1===c.length){const t=Math.abs(r.center[e.opposite]-r.halfSize[e.opposite]-e.min)<s.ANCHOR_DISTANCE,i=Math.abs(r.center[e.opposite]+r.halfSize[e.opposite]-e.max)<s.ANCHOR_DISTANCE;if(t&&i){const{minSize:t,maxSize:i,resizableMin:n,resizableMax:s}=r.resizeConstraints[e.opposite],o=e.max-e.min;(n||s)&&o>=t&&o<=i&&(d[e.opposite]=o/2),a[e.opposite]=(e.min+e.max)/2-r.center[e.opposite],a[e.opposite]=(e.min+e.max)/2-r.center[e.opposite]+(r.halfSize[e.opposite]-d[e.opposite])}else t?a[e.opposite]=e.min-r.center[e.opposite]+d[e.opposite]:i&&(a[e.opposite]=e.max-r.center[e.opposite]-d[e.opposite])}}else e.direction<2&&(d[e.orientation]=Math.abs(e.limit-t.limit)/2,a[e.orientation]=(e.limit+t.limit)/2-r.center[e.orientation],a[e.orientation]+=r.halfSize[e.orientation]-d[e.orientation])}),{targetGroup:e,activeWindow:t,offset:a,halfSize:d,valid:!0,type:n.eTargetType.SNAP}}return null}getDirectionFromOffset(e,t,i){let n;return"x"==(n=Math.sign(e.x)===Math.sign(e.y)?e.x>e.y?"x":"y":e.x>=0?"x":"y")?t.center.x<i.center.x?d.LEFT:d.RIGHT:t.center.y<i.center.y?d.TOP:d.BOTTOM}clipProjections(){const e=this._borders;for(let t=0;t<4;t++)e[t].clip(e[(t+1)%4]),e[t].clip(e[(t+3)%4])}};class c{constructor(e){this.direction=e,this.orientation=e%2?"y":"x",this.opposite=e%2?"x":"y",this.limit=this.direction<2?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER,this.distance=Number.MAX_SAFE_INTEGER,this.min=Number.MAX_SAFE_INTEGER,this.max=Number.MIN_SAFE_INTEGER}project(e,t,i){if(i.x<-s.SNAP_DISTANCE&&i.y<-s.SNAP_DISTANCE)return!1;if(i.border(Math.max(s.SNAP_DISTANCE,s.ANCHOR_DISTANCE))){const n=this.orientation,s=t.center[n]+t.halfSize[n]*Math.sign(e.center[n]-t.center[n]);return this.limit=this.direction<2?Math.min(this.limit,s):Math.max(this.limit,s),this.addToRange(e,t,i[n])}return!0}getOverlap(e){const t=(this.min+this.max)/2,i=(this.max-this.min)/2;return e.halfSize[this.opposite]+i-Math.abs(e.center[this.opposite]-t)}clip(e){if(e.distance<Number.MAX_SAFE_INTEGER&&r.RangeUtils.within(this,e.limit)){const t=(this.min+this.max)/2;e.limit<t?this.min=Math.max(this.min,e.limit):this.max=Math.min(this.max,e.limit)}}addToRange(e,t,i){if(i<=this.distance){const n=this.opposite;if(Math.abs(e.center[n]-t.center[n])>e.halfSize[n]+t.halfSize[n])return console.log("No overlap in "+n+" axis"),!0;this.distance=i;const s=t.center[n]-t.halfSize[n],o=t.center[n]+t.halfSize[n];if(!(this.min>this.max||r.RangeUtils.within(this,s)||r.RangeUtils.within(this,o))&&!this.windowBridgesRanges(e,r.RangeUtils.createFromRect(t,this.opposite)))return console.log("Window falls within gap"),!1;this.min=Math.min(this.min,s),this.max=Math.max(this.max,o)}return!0}windowBridgesRanges(e,t){const i=Math.min(this.max,t.max),n=Math.max(this.min,t.min),s=e.center[this.opposite],o=e.halfSize[this.opposite];return i>=s-o&&n<=s+o}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=i(2),s=i(40),o=i(6);t.View=class{constructor(e){this._config=e,this._preview=new s.Preview(e),this._targetItem=null,this._activeItem=null}update(e){const t=e&&e.activeWindow.snapGroup||null;let i=null,n=null;if(e&&t)switch(e.type){case o.eTargetType.SNAP:i=t,n=e.targetGroup;break;case o.eTargetType.TAB:e.targetWindow.tabGroup&&e.activeWindow.tabGroup&&e.targetWindow.tabGroup===e.activeWindow.tabGroup?(n=e.activeWindow.tabGroup.window,i=e.activeWindow.tabGroup.window):(n=e.targetWindow,i=e.activeWindow);break;case o.eTargetType.EJECT:i=null,n=null;break;default:i=t}else i=null,n=null;if(i!==this._activeItem){this.setAlwaysOnTop(this._activeItem,!1),this.setOpacity(this._activeItem,null,!0);const t=null!==e&&!(e.type===o.eTargetType.TAB&&e.tabDragging&&i!==n);this.setAlwaysOnTop(i,t),this.setOpacity(i,i!==n?e:null,!0),this._activeItem=i}else if(this._activeItem===this._targetItem!=(i===n)){const t=null!==e&&!(e.type===o.eTargetType.TAB&&e.tabDragging&&i!==n);this.setAlwaysOnTop(i,t),this.setOpacity(i,t?null:e,!0)}n!==this._targetItem&&(this._targetItem!==i&&this.setOpacity(this._targetItem,null,!1),this.setOpacity(n,i!==n?e:null,!1)),this._targetItem=n,i&&n&&i!==n?this._preview.show(e):this._preview.hide()}setAlwaysOnTop(e,t){e&&(e instanceof n.DesktopSnapGroup?e.windows.forEach(e=>{t?e.applyOverride("alwaysOnTop",!0):e.resetOverride("alwaysOnTop")}):t?e.applyOverride("alwaysOnTop",!0):e.resetOverride("alwaysOnTop"))}setOpacity(e,t,i){e&&(t&&t.type!==o.eTargetType.SNAP&&t.type!==o.eTargetType.TAB||(e instanceof n.DesktopSnapGroup?e.windows.forEach(e=>{this.setEntityOpacity(e,t,i)}):this.setEntityOpacity(e.tabGroup||e,t,i)))}setEntityOpacity(e,t,i){if(t){const n=e.tabGroup?e.tabGroup.activeTab.scope:e.scope,s=o.eTargetType[t.type].toLowerCase(),r=this._config.query(n).preview[s],a=i?r.activeOpacity:r.targetOpacity;null!==a?e.applyOverride("opacity",a):e.resetOverride("opacity")}else e.resetOverride("opacity")}}},function(e,t,i){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=n(i(16)),o=i(6),r=i(2),a=i(41);t.Preview=class{constructor(e){this._activeWindowPreview=null,this._config=e,this._previewWindows=a.createPreviewMap((e,t)=>({previewWindow:this.createWindow(`preview-${e}-${t}`),opacity:0})),r.DesktopSnapGroup.onCreated.add(this.onCreated,this)}show(e){const t=e.valid?a.Validity.VALID:a.Validity.INVALID,i=e.type.toLowerCase(),{previewWindow:n,opacity:s}=this._previewWindows[i][t];this.applyScopeStyles(e.activeWindow.scope),this.positionPreview(n,e),n.updateOptions({opacity:s}),n!==this._activeWindowPreview&&(this.hide(),this._activeWindowPreview=n)}hide(){null!==this._activeWindowPreview&&(this._activeWindowPreview.updateOptions({opacity:0}),this._activeWindowPreview=null)}onCreated(e){e.onTransform.add(this.onTransform,this)}onTransform(e,t){const i=e.windows[0],n=i.tabGroup?i.tabGroup.activeTab.scope:i.scope;this.applyScopeStyles(n)}applyScopeStyles(e){if(s.default(this._lastScope,e))return;const t=this._config.query(e).preview;a.forEachPreviewMap(this._previewWindows,(e,i,n)=>{const{previewWindow:s}=e,{document:o}=s.getNativeWindow(),r=t[i][n];this._previewWindows[i][n].opacity=r.opacity,o.body.style.background=r.background,o.body.style.border=r.border}),this._lastScope=e}createWindow(e){const t={name:e,url:"about:blank",defaultWidth:320,defaultHeight:320,opacity:0,minimizable:!1,maximizable:!1,defaultTop:0,defaultLeft:0,showTaskbarIcon:!1,frame:!1,state:"normal",saveWindowState:!1,autoShow:!1,alwaysOnTop:!0},i=new fin.desktop.Window(t,()=>{i.showAt(-1e4,-1e4)});return i}positionPreview(e,t){const i=this.generatePreviewRect(t);e.setBounds(i.center.x-i.halfSize.x,i.center.y-i.halfSize.y,2*i.halfSize.x,2*i.halfSize.y)}generatePreviewRect(e){if(e.type===o.eTargetType.SNAP){const t=e.activeWindow.currentState,i=t.halfSize,n=e.halfSize||i;return{center:{x:t.center.x+e.offset.x+(n.x-i.x),y:t.center.y+e.offset.y+(n.y-i.y)},halfSize:n}}return e.dropArea}}},function(e,t,i){"use strict";var n,s;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.TAB="tab",e.SNAP="snap"}(n=t.PreviewType||(t.PreviewType={})),function(e){e.VALID="overlayValid",e.INVALID="overlayInvalid"}(s=t.Validity||(t.Validity={}));const o=Object.keys(n).map(e=>e.toLowerCase());t.createPreviewMap=function(e){return o.reduce((t,i)=>Object.assign({},t,{[i]:{[s.VALID]:e(i,s.VALID),[s.INVALID]:e(i,s.INVALID)}}),{})},t.forEachPreviewMap=async function(e,t){for(const i in e){const n=i;await t(e[n][s.VALID],n,s.VALID),await t(e[n][s.INVALID],n,s.INVALID)}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.RangeUtils=class{static size(e){return e.max-e.min}static equal(e,t){return e.min===t.min&&e.max===t.max}static within(e,t){return t>=e.min&&t<=e.max}static createFromRect(e,t){return{min:e.center[t]-e.halfSize[t],max:e.center[t]+e.halfSize[t]}}static snap(e,t,i,n){const s=Math.abs(e.min-t.min)<i,o=Math.abs(e.max-t.max)<i,r=s?e.min:t.min,a=o?e.max:t.max;if(s!==o)return Math.abs(this.size(e)-this.size(t))<i?Object.assign({},e):s?{min:r,max:r+this.size(t)}:{min:a-this.size(t),max:a};if(s&&!n){const i=this.size(t)/2,n=(e.min+e.max)/2;return{min:n-i,max:n+i}}return{min:r,max:a}}}},function(e,t,i){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=n(i(16)),o=i(2),r=i(10),a=i(20),d=i(13),c=i(4),l=i(3),h=i(6),u=i(18);t.TabService=class{constructor(e,t){this._model=e,this._dragWindowManager=new u.DragWindowManager(e),this._config=t,this._config.add({level:"service"},{tabstrip:a.DesktopTabstripFactory.DEFAULT_CONFIG})}get dragWindowManager(){return this._dragWindowManager}async createTabGroupWithTabs(e,t){if(e.length<2)throw console.error("createTabGroup called fewer than 2 tab identifiers"),new Error("Must provide at least 2 Tab Identifiers");e.forEach(t=>{if(e.filter(e=>e.name===t.name&&e.uuid==e.uuid).length>1)throw new Error(`Duplicate identity found: ${t.uuid}/${t.name} - Provided identites must be unique.`)});const i=e.map(e=>this._model.getWindow(e)).filter(e=>null!==e&&this._config.query(e.scope).features.tab);if(i.length!==e.length){if(i.length<2)throw new Error("Must have at least two valid tab identities to create a tab group: "+e.map(e=>`${e.uuid}/${e.name}`).join("\n"));console.warn(`Tab list contained ${e.length-i.length} invalid identities`,e,i.map(e=>e.identity))}const n=i[0].tabGroup;if(n){const e=n.tabs.filter(e=>!i.includes(e));if(await d.promiseForEach(e,async e=>{await n.removeTab(e)}),e.length>1){const t=this.getTabstripConfig(e[0].identity),i=new r.DesktopTabGroup(this._model,new o.DesktopSnapGroup,t);await i.addTabs(e)}else 1===e.length&&e[0].setSnapGroup(new o.DesktopSnapGroup)}const s=this.getTabstripConfig(e[0]),a=i[0].snapGroup.isNonTrivial()?i[0].snapGroup:new o.DesktopSnapGroup,c=new r.DesktopTabGroup(this._model,a,s);await c.addTabs(i,t)}async removeTab(e){const t=this._model.getWindow(e),i=t&&t.tabGroup;i&&await i.removeTab(t)}async swapTab(e,t){const i=this._model.getWindow(t),n=this._model.getWindow(e),s=n&&n.tabGroup;if(!n||!s)throw new Error(`No tab group found for ${e.uuid} - ${e.name}`);if(!i)throw new Error(`No window found for ${t.uuid} - ${t.name}`);return s.swapTab(n,i)}async getTabSaveInfo(){const e=this._model.tabGroups;return Promise.all(e.map(async e=>{const t=e.tabs.map(e=>e.identity),i=this.areTabstripConfigurationsCompatible(e.config,a.DesktopTabstripFactory.DEFAULT_CONFIG)?"default":e.config;return{tabs:t,groupInfo:{active:e.activeTab.identity,dimensions:e.getSaveDimensions(),config:i,state:e.state}}}))}async createTabGroupsFromWorkspace(e){const t=this._model,i=[];if(!e)throw console.error("Unable to create tabgroup - no blob supplied"),new Error("Unable to create tabgroup - no blob supplied");for(const n of e){const e=n.tabs.map(e=>t.getWindow(e)).filter(e=>!!e),s=n.groupInfo.dimensions;if(e.length>=2){const t=a.DesktopTabstripFactory.convertToTabstripConfig(n.groupInfo.config),d=new o.DesktopSnapGroup,c=new r.DesktopTabGroup(this._model,d,t),l=t.height+s.appHeight,h={center:{x:s.x+s.width/2,y:s.y+l/2},halfSize:{x:s.width/2,y:l/2}};await e[0].applyProperties(h),await c.window.sync(),await c.addTabs(e,n.groupInfo.active),await c.window.sync(),"maximized"===n.groupInfo.state?await c.maximize().catch(console.warn):"minimized"===n.groupInfo.state&&await c.minimize(),i.push(c)}else console.error("Not enough valid tab identifiers within tab blob to form a tab group",n.tabs)}return i}getTabProperties(e){const t=localStorage.getItem(e.id);if(t)return JSON.parse(t);const{icon:i,title:n}=e.currentState;return""===n&&e.refresh().then(()=>{const{icon:t,title:i}=e.currentState;if(""!==i){const n={icon:t,title:i},s={identity:e.identity,properties:n,type:"tab-properties-updated"};this.sendTabEvent(e,s)}},console.warn),{icon:i,title:n||e.identity.name}}updateTabProperties(e,t){const i=this.getTabProperties(e),n=Object.assign({},i,t);if(!s.default(n,i)){Object.assign(i,t),localStorage.setItem(e.id,JSON.stringify(i));const n={identity:e.identity,properties:i,type:"tab-properties-updated"};this.sendTabEvent(e,n)}}async applyTabTarget(e){const t=e.activeWindow.identity,i=e.activeWindow.tabGroup,n=e.type===h.eTargetType.TAB&&e.targetWindow,s=n&&n.tabGroup,o=e.valid,r=this._model.getWindow(t);if(r)if(s)i!==s&&o&&(i&&await i.removeTab(r),await s.addTab(r));else if(o&&n&&!s&&e.valid)i&&(await i.removeTab(r),await r.setAsForeground()),await fin.InterApplicationBus.send(t,"should-tab-to",n.identity);else if(e.type===h.eTargetType.EJECT&&i){const t=r.currentState.halfSize,n={x:t.x,y:t.y+i.config.height/2},s={x:e.position.x+n.x,y:e.position.y+n.y};await i.removeTab(r,{center:s,halfSize:n}),await r.setAsForeground()}}getTarget(e){const t=this._model.mouseTracker.getPosition();if(!t)return null;if(!this.isEntityTabEnabled(e))return null;const i=e.snapGroup,n=this.getTargetWindow(t,e),s=e.tabGroup?l.RectUtils.isPointInRect(e.tabGroup.currentState.center,e.tabGroup.currentState.halfSize,t):l.RectUtils.isPointInRect(e.currentState.center,e.currentState.halfSize,t),o=!!n&&this.isOverWindowDropArea(n,t),r=e.tabGroup,a=i.isNonTrivial(),d=!!n&&n.snapGroup===i,c=n&&!a&&!d&&o&&!r,u=n&&this._model.mouseTracker.isDraggingTab&&o;if(n&&(c||u)){const t=n.tabGroup,i=this.constraintsCompatible(e,t||n)&&this.doEntitiesShareTabstripConfig(n,e);return{type:h.eTargetType.TAB,activeWindow:e,targetWindow:n,dropArea:this.getWindowDropArea(n),valid:i,tabDragging:this._model.mouseTracker.isDraggingTab}}return r&&this._model.mouseTracker.isDraggingTab&&(!s||s&&!this.isOverWindowDropArea(e,t))?{type:h.eTargetType.EJECT,activeWindow:e,position:t,valid:!0}:null}canTabTogether(e,t){return this.isEntityTabEnabled(e)&&this.isEntityTabEnabled(t)&&this.doEntitiesShareTabstripConfig(e,t)}doEntitiesShareTabstripConfig(e,t){const i=[e,t].map(e=>e.tabGroup&&e.tabGroup.window===e?e.tabGroup.config:this._config.query(e.scope).tabstrip);return this.areTabstripConfigurationsCompatible(i[0],i[1])}areTabstripConfigurationsCompatible(e,t){return e.url===t.url&&e.height===t.height}isEntityTabEnabled(e){return!(!e.tabGroup||e.tabGroup.window!==e)||this._config.query(e.scope).features.tab}getScope(e){return e.scope||Object.assign({level:"window"},e)}sendTabEvent(e,t){e.sendEvent(t),e.tabGroup&&e.tabGroup.window.sendEvent(t)}getTabstripConfig(e){return this._config.query(this.getScope(e)).tabstrip}isOverWindowDropArea(e,t){const{center:i,halfSize:n}=this.getWindowDropArea(e);return l.RectUtils.isPointInRect(i,n,t)}getWindowDropArea(e){const t=e.tabGroup;if(t){const{halfSize:e,center:i}=t.window.currentState;return{center:i,halfSize:e}}{const t=e.currentState,i=this.getTabstripConfig(e);return{center:{x:t.center.x,y:t.center.y-t.halfSize.y+i.height/2},halfSize:{x:t.halfSize.x,y:i.height/2}}}}getTargetWindow(e,t){const i=this._model.mouseTracker.isDraggingTab?void 0:t.identity,n=this._model.getWindowAt(e.x,e.y,i);return n&&this.isEntityTabEnabled(n)?n:null}constraintsCompatible(e,t){const i=c.PointUtils.scale(t.currentState.halfSize,2),n=c.PointUtils.scale(e.currentState.halfSize,2),s=t.currentState.resizeConstraints,o=e.currentState.resizeConstraints;t.tabGroup||(i.y-=this._config.query(t.scope).tabstrip.height),e.tabGroup||(n.y-=this._config.query(e.scope).tabstrip.height);let r=!0;return r=(r=(r=(r=(r=r&&(i.x===n.x||o.x.resizableMin||o.x.resizableMax)&&(i.y===n.y||o.y.resizableMin||o.y.resizableMax))&&(s.y.resizableMin||s.y.resizableMax))&&i.x>=o.x.minSize&&i.x<=o.x.maxSize&&i.y>=o.y.minSize&&i.y<=o.y.maxSize)&&i.y>=s.y.minSize)&&s.x.maxSize>=o.x.minSize&&s.x.minSize<=o.x.maxSize&&s.y.maxSize>=o.y.minSize&&s.y.minSize<=o.y.maxSize}}},function(e){e.exports=JSON.parse('{"enabled":true,"features":{"snap":true,"dock":true,"tab":true},"preview":{"snap":{"activeOpacity":0.8,"targetOpacity":0.8,"overlayValid":{"opacity":0.8,"background":"rgb(61, 64, 89)","border":""},"overlayInvalid":{"opacity":0.8,"background":"repeating-linear-gradient(45deg, rgb(61, 64, 89), rgb(61, 64, 89) 0.25em, rgb(194, 70, 41) 0px, rgb(194, 70, 41) 0.5em)","border":""}},"tab":{"activeOpacity":0.8,"targetOpacity":0.8,"overlayValid":{"opacity":0.8,"background":"rgb(61, 64, 89)","border":""},"overlayInvalid":{"opacity":0.8,"background":"repeating-linear-gradient(45deg, rgb(61, 64, 89), rgb(61, 64, 89) 0.25em, rgb(194, 70, 41) 0px, rgb(194, 70, 41) 0.5em)","border":""}}},"tabstrip":{"url":"","height":60}}')}]);